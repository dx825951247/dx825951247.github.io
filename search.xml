<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis数据类型值为0时非空判断问题]]></title>
    <url>%2FmybatisZeroNull.html</url>
    <content type="text"><![CDATA[123&lt;if test="age != null and age != ''"&gt; #&#123;age,jdbcType=NUMERIC&#125;&lt;/if&gt; 当age为0时，此判断不成立，sql可能报错。导致错误原因是，0被视为false，0 != &#39;&#39;自然也不会成立，数字类型进行非空字符判断本身也不合理。解决此问题办法，如下去掉非空判断：123&lt;if test="age != null"&gt; #&#123;age,jdbcType=NUMERIC&#125;&lt;/if&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next博客链接与常用Markdown语法]]></title>
    <url>%2FnextPage.html</url>
    <content type="text"><![CDATA[量子广告务虚笔记小桥流水人家Jing’s BlogDoublemine岁月如歌胡闹的日子Never_yu’s Blog SEO优化博客 Bootstrap CalloutContent (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Next标签插件Code Block1alert(&apos;Hello World!&apos;); Pull Quotecontent 代码块hexo-generator-indexhexo-generator-index 加粗single asterisks single underscores double asterisks double underscores]]></content>
      <categories>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Next</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis返回结果集Map or 实体类]]></title>
    <url>%2FmybatisReturn.html</url>
    <content type="text"><![CDATA[观点1：一般的配置项表的结构不太会变化，服务层还有业务操作，使用实体类好些，如果返回结果是多层组合，返回结构字段可能经常变化，多表联合查询，使用Map好些。 观点2：使用Map可读性较差，当你前端用Map接收传递参数和mybatis返回用Map接收和传递参数，如果回头阅读代码，还得去看前端请求或者具体sql返回结果。如果是他人接手你的项目，得从头到尾得读一遍你的代码。如果你返回的是一个对象实体，那他就可以看到你返回的是什么，别人也就不需要再去看你代码了，提高了开发效率。 观点3：MyBatis也是ORM(Object Relational Mapping)框架的一员，使用Map从业界准则来看，不符合面向对象思想，这是一个代码规范问题。 观点4：采用实体类比Map更耗费系统资源，如下图所示：]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle创建自增长字段函数]]></title>
    <url>%2FincreaseIdOracle.html</url>
    <content type="text"><![CDATA[一.创建序列号1234567create sequence SEQ_VEN_CODEminvalue 1maxvalue 999999999999start with 74increment by 1nocachecycle; 二.创建自增长函数12345678910111213141516171819CREATE OR REPLACE FUNCTION FUN_VEN_CODE(VEN_TYPE VARCHAR2) RETURN VARCHAR2 IS VEN_CODE VARCHAR2(30);BEGIN IF VEN_TYPE = 'LOGISTICS' THEN SELECT 'L' || LTRIM(TO_CHAR(SYSDATE, 'yyyymmdd')) || LPAD(SEQ_VEN_CODE.NEXTVAL, 5, '0') INTO VEN_CODE FROM DUAL; ELSIF VEN_TYPE = 'GOODS' THEN SELECT 'G' || LTRIM(TO_CHAR(SYSDATE, 'yyyymmdd')) || LPAD(SEQ_VEN_CODE.NEXTVAL, 5, '0') INTO VEN_CODE FROM DUAL; END IF; RETURN TRIM(VEN_CODE);EXCEPTION WHEN OTHERS THEN RETURN '0';END; 三.查询 select FUN_VEN_CODE(&#39;LOGISTICS&#39;) from dual 结果：L2017101700072 select FUN_VEN_CODE(&#39;GOODS&#39;) from dual 结果：G2017101700073]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISODate转String]]></title>
    <url>%2FconvertISODateToString.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324/** * convertISODateToString * @param time 2017-09-07T16:00:00.000Z * @return */ &lt;!--more--&gt;public static String convertISODateToString(String time)&#123; if(!time.matches("\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;T\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;.\\d&#123;3&#125;Z"))&#123; return null; &#125; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); time=time.replaceFirst("T", " ").replaceFirst(".\\d&#123;3&#125;Z", ""); Date date; try &#123; date = sdf.parse(time); Calendar ca=Calendar.getInstance(); ca.setTime(date); ca.add(Calendar.HOUR_OF_DAY, 8); time = sdf.format(date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return time; &#125; 参考文章]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[业务流程异常处理]]></title>
    <url>%2FserviceException.html</url>
    <content type="text"><![CDATA[一、异常分类在web系统开发中，异常可大致分为: 系统异常:软件的缺陷，客户端对此类异常是无能为力的,系统内部未知异常。 业务异常用户未按正常流程操作导致的异常。 二、处理方式在实际开发中，常见的异常处理方式有:1.系统异常采用try{}catch{}处理,在service抛出异常，由controller层得到异常信息在返回,最好定义一个异常信息枚举类，集中记录异常信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556`service`层：try &#123; //service代码 &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ServiceException(ErrorCode.SYSTEM_ERROR); &#125;枚举类`ErrorCode`：/** * @author * errorCode 错误代码 * sysMsg 系统显示信息（一般用于日志输出） * showMsg 页面显示信息（一般用于页面提示用户） * */public enum ErrorCode &#123; SYSTEM_ERROR(10086,"","系统异常！"), CODE_EXIST(101111101,"","code码已存在已存在！"); int errorCode; String sysMsg; String showMsg; ErrorCode(int errorCode, String sysMsg, String showMsg)&#123; this.errorCode = errorCode; this.sysMsg = sysMsg; this.showMsg = showMsg; &#125; public int getErrorCode()&#123; return errorCode; &#125; public String getSysMsg()&#123; return sysMsg; &#125; public String getShowMsg()&#123; return showMsg; &#125; public void setShowMsg(String showMsg)&#123; this.showMsg = showMsg; &#125; public void setSysMsg(String sysMsg)&#123; this.sysMsg = sysMsg; &#125;&#125;`controller`层：try &#123; //controller代码 &#125; catch (ModuleException e) &#123; //通过枚举类返回错误码和错误信息 return ResponseError.create(e.getErrorCode().getErrorCode(),e.getErrorCode().getShowMsg()); &#125; 2.业务异常可以采用try{}catch{}处理，或者采用if加错误码判断处理如果采用try{}catch{}方式，和上面方式一致，下面介绍采用if加错误码处理,定义一个对象，每次处理加上返回码和错误信息提示。12345ReturnResultObj obj = new ReturnResultObj();obj.setCode("101112101");obj.setMessage("name不能为空!");obj.setData("");return obj; 三、两种方式优缺点： 用if加错误码控制业务流程,需要对每个接口的返回都要做一个错误码的校验,判断的代码会遍布在你的业务代码里面。优点就是对调用方,不必对你的接口进行异常校验,因为你的接口只可能返回「正确」或者「错误」,代码可读性高，但是随之带来的代码显得很臃肿，错误码集中在代码里，后期维护困难，但在效率上面也会更加高一点。对某些人来说,用错误码来控制业务流程更能符合「异常」的语义。 用if加错误码控制业务流程,因为没有抛出RuntimeException，如果在写操作之后加入业务判断，会导致事务无法回滚，因此写操作之前进行所有业务判断。 用异常来控制业务流程,可以把错误处理集中在一处,对客户端的代码编写更加友好,代码清晰简洁，在业务代码里面不会有很多错误码的判断。缺点就是创建异常堆栈是需要时间和空间的,异常处理性能开销在于-是一个synchronized方法(主因)-需要填充线程运行堆栈信息但是可以通过复写业务异常基类的方法Throwable.fillInStackTrace()来提示性能。123public Throwable fillInStackTrace() &#123; return null;&#125; 参考文章:https://segmentfault.com/q/1010000004308144?_ea=564305http://blog.csdn.net/liujun13579/article/details/7742380]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>业务，异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis嵌套查询传入多个参数]]></title>
    <url>%2FMybatisNestedSelect.html</url>
    <content type="text"><![CDATA[resultMap constructor - 类在实例化时,用来注入结果到构造方法中 dArg - ID 参数;标记结果作为 ID 可以帮助提高整体效能 arg - 注入到构造方法的一个普通结果 id – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能 result – 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂的类型关联;许多结果将包成这种类型 嵌入结果映射 – 结果映射自身的关联,或者参考一个 collection – 复杂类型的集 嵌套嵌入结果映射, 结果映射自身的集,或者参考一个 collection标签中的select属性，通过这个属性，通过ID引用另一个加载复杂类型的映射语句。从指定列属性中返回的值，将作为参数设置给目标select 语句。注意：在处理组合键时，也就是传入多个参数时，可以使用column=”{pro1=col1,pro2=col2}”这样的语法，这就会把prop1和prop2设置到目标嵌套语句的参数对象中，在子查询中就可以作为参数使用#{pro1},#{pro2}。 discriminator – 使用结果值来决定使用哪个结果映射 case – 基于某些值的结果映射嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。 12345678910111213141516171819202122232425262728293031323334&lt;select id="getTest" parameterType="Test" resultMap="getTestMap"&gt; select AAA, BBB, CCC from test where '1' = '1' and AAA = #&#123;aaa,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" column="&#123;aaa=AAA,bbb=BBB&#125;" ofType="TestValue" javaType="ArrayList" select="selectTestValues"/&gt;&lt;/resultMap&gt;&lt;select id="selectTestValues" resultMap="selectTestValuesMap"&gt; select DDD, EEE from test_value where AAA = #&#123;aaa,jdbcType=VARCHAR&#125; and BBB = #&#123;bbb,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;resultMap id="selectTestValuesMap" type="TestValue" &gt; &lt;result column="DDD" property="ddd" jdbcType="VARCHAR" /&gt; &lt;result column="EEE" property="eee" jdbcType="VARCHAR" /&gt;&lt;/resultMap&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Oracle</tag>
        <tag>管理查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库批量插入、批量更新]]></title>
    <url>%2ForacleInsert.html</url>
    <content type="text"><![CDATA[一.xml中批量插入三种方式 1.使用union all sql中没有VALUES 中的select…插入数据…from dual 1234567891011122017/10/18INSERT INTO STUDENT ( NAME， AGE )&lt;foreach collection="templateDetial" item="item" index="index" separator="union all" &gt; SELECT #&#123;item.name&#125;, #&#123;item.age&#125; FROM DUAL &lt;/foreach&gt; 2.insert all sql中有VALUES 分隔符是空格,这种方式可以返回插入总条数 12345678910111213INSERT ALL &lt;foreach collection="list" item="item" index="index" separator=" "&gt; INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) &lt;/foreach&gt;SELECT 1 FROM DUAL 批量插入多表 12345678910111213141516171819202122INSERT ALL &lt;foreach collection="carouselList" item="item" index="index" separator=" "&gt; INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) INTO STUDENT2 ( NAME2， AGE2 ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) &lt;/foreach&gt;SELECT 1 FROM DUAL 3.begin end模式 分隔符是 ;插入成功，返回插入总条数始终未-11234567891011&lt;foreach collection="list" item="item" index="index" open="begin" close=";end;" separator=";"&gt; INSERT INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; )&lt;/foreach&gt; 二.在代码中使用batch模式,效率最高Mybatis有三种执行器： SIMPLE是普通的执行器，相当于JDBC的stmt.execute(sql) REUSE执行器会重用预处理语句(prepared statements)，相当于JDBC重用一条sql，再通过stmt传入多项参数值，然后执行stmt.executeUpdate()或stmt.executeBatch() BATCH执行器将重用语句并执行批量更新，相当于JDBC语句的stmt.addBatch(sql)，即仅仅是将执行SQL加入到批量计划。当插入主键时不会抛出主键冲突等运行时异常，而只有临近commit前执行stmt.execteBatch()后才会抛出异常。1234567891011121314151617181920212223242526public void test() &#123; //新获取一个模式为BATCH，自动提交为false的session //如果自动提交设置为true,将无法控制提交的条数，改为最后统一提交，可能导致内存溢出 SqlSession session = sqlSessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH, false); //通过新的session获取mapper testMapper = session.getMapper(testMapper.class); int size = 10000; try &#123; for (int i = 0; i &lt; size; i++) &#123; Test test = new Test(); test.setName(String.valueOf(System.currentTimeMillis())); testMapper.insert(test); if (i % 1000 == 0 || i == size - 1) &#123; //手动每1000个一提交，提交后无法回滚 session.commit(); //清理缓存，防止溢出 session.clearCache(); &#125; &#125; &#125; catch (Exception e) &#123; //没有提交的数据可以回滚 session.rollback(); &#125; finally &#123; session.close(); &#125;&#125; 三.批量更新12345678910&lt;update id="updateStudent" parameterType="java.util.Map"&gt; &lt;foreach collection="list" item="item" index="index" open="begin" close=";end;" separator=";"&gt; UPDATE STUDENT SET AGE = '0' WHERE NAME = #&#123;item.name&#125; &lt;/foreach&gt;&lt;/update&gt; 参考链接MyBatis的几种批量操作关于Mybatis的Batch模式性能测试及结论]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
</search>
