<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx代理Tomcat服务器获取客户端真实IP]]></title>
    <url>%2FnginxIP.html</url>
    <content type="text"><![CDATA[一、背景 Java Web项目中经常需要在后端获取前端IP，通过request.getRemoteAddr()这种方法只会获取到上一级的IP，在通过了Nginx，Apache等反向代理服务器，此方法获取的就是服务器的IP，而不是客户端的真实IP地址。 这是反向代理的原因,TCP连接是在代理和网站之间，而非用户与网站之间的；HTTP协议只是第七层协议，不会把IP层访问者的源IP信息同时发送。因此服务器无法得到客户端地真实IP，但是可以通过X-Forwarded-For绕过服务器IP地址过滤。 X-Forwarded-For（简称XFF） X-Forwarded-For是一个HTTP扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由Squid这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 RFC 7239（Forwarded HTTP Extension）标准之中。XFF的格式为：X-Forwarded-For: client, proxy1, proxy2 XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP。（注意：如果未经严格处理，可以被伪造） 二、解决方案在Nginx配置中的location节点中加入123proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 其中$proxy_add_x_forwarded_for会累加代理层的IP向后传递 服务器端通过X-Forwarded-For请求头获取IP1234567891011121314151617181920212223public static String getIpAddress(HttpServletRequest request) &#123; String ipAddress = request.getHeader("X-Forwarded-For"); if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getHeader("Proxy-Client-IP"); &#125; if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getHeader("WL-Proxy-Client-IP"); &#125; if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getRemoteAddr(); &#125; // 对于通过多个代理的情况，第一个IP为客户端真实的IP地址，多个IP按照','分割 if (null != ipAddress &amp;&amp; ipAddress.length() &gt; 15) &#123; // "***.***.***.***".length() = 15 if (ipAddress.indexOf(",") &gt; 0) &#123; ipAddress = ipAddress.substring(0, ipAddress.indexOf(",")); &#125; &#125; return ipAddress.equals("0:0:0:0:0:0:0:1") ? "127.0.0.1" : ipAddress;&#125; 三、思考 通过X-Forwarded-For获取到了客户端真实IP，但其实际上是把IP放在请求头中传递给服务器端，所以这个XFF的名称是可以自定义的。比如可以定义为my-client-IP之类，然后记得在Web程序那边设定好去取这个名为my-client-IP的头标即可。 通过request.getRemoteAddr()获取的Remote Address无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源IP，无法建立TCP连接，更不会有后面的HTTP请求。但是在正常情况下，Web服务器获取Remote Address只会获取到上一级的IP。 当多层代理或使用CDN时，如果代理服务器不把用户的真实IP传递下去，那么业务服务器将永远不可能获取到用户的真实IP。 X-Forwarded-For这种方式，客户端可以任意伪造IP，并且可以传入任意格式IP，这样会产生很多问题 如果服务端通过IP做限制，前端很容易通过修改IP跳过限制。 如果直接使用这样的IP，会带来SQL注入，服务端报错，跨站攻击等漏洞。 投票系统就可能被这种方式伪造IP刷票。 X-Forwarded-For绕过服务器IP地址过滤Nginx 如何配置来获取用户真实IP]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx不转发某些http header问题]]></title>
    <url>%2FnginxHeader.html</url>
    <content type="text"><![CDATA[当项目中使用自定义的请求头时，一定要注意请求头名称不能带有下划线，用Nginx做http代理时，像token_id这样的请求头，Nginx默认不转发，因为Nginx会默认过滤带有下划线的请求头。解决办法： 配置中http部分 增加underscores_in_headers on;配置。 用减号-替代下划线符号_，避免这种变态问题。或者不使用含有下划线的请求头。 nginx 做proxy 不转发 http header问题解决]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀文章汇总]]></title>
    <url>%2Fmark.html</url>
    <content type="text"><![CDATA[权限管理及实现思路]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis数据类型值为0时非空判断问题]]></title>
    <url>%2FmybatisZeroNull.html</url>
    <content type="text"><![CDATA[123&lt;if test="age != null and age != ''"&gt; #&#123;age,jdbcType=NUMERIC&#125;&lt;/if&gt; 当age为0时，此判断不成立，sql可能报错。导致错误原因是，0被视为false，0 != &#39;&#39;自然也不会成立，数字类型进行非空字符判断本身也不合理。解决此问题办法，如下去掉非空判断：123&lt;if test="age != null"&gt; #&#123;age,jdbcType=NUMERIC&#125;&lt;/if&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next博客链接与常用Markdown语法]]></title>
    <url>%2FnextPage.html</url>
    <content type="text"><![CDATA[量子广告务虚笔记小桥流水人家Jing’s BlogDoublemine岁月如歌胡闹的日子Never_yu’s Blog SEO优化博客 Bootstrap CalloutContent (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) 将博客源文件上传至好hexo分支deploy: type: gitrepo: https://github.com/dx825951247/dx825951247.github.io.gitbranch: master type: gitrepo: https://github.com/dx825951247/dx825951247.github.io.gitbranch: hexoextend_dirs: /ignore_hidden: falseignore_pattern:public: . type: baidu_url_submitter Next标签插件Code Block1alert(&apos;Hello World!&apos;); Pull Quotecontent]]></content>
      <categories>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Next</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis返回结果集Map or 实体类]]></title>
    <url>%2FmybatisReturn.html</url>
    <content type="text"><![CDATA[观点1：一般的配置项表的结构不太会变化，服务层还有业务操作，使用实体类好些，如果返回结果是多层组合，返回结构字段可能经常变化，多表联合查询，使用Map好些。 观点2：使用Map可读性较差，当你前端用Map接收传递参数和mybatis返回用Map接收和传递参数，如果回头阅读代码，还得去看前端请求或者具体sql返回结果。如果是他人接手你的项目，得从头到尾得读一遍你的代码。如果你返回的是一个对象实体，那他就可以看到你返回的是什么，别人也就不需要再去看你代码了，提高了开发效率。 观点3：MyBatis也是ORM(Object Relational Mapping)框架的一员，使用Map从业界准则来看，不符合面向对象思想，这是一个代码规范问题。 观点4：采用实体类比Map更耗费系统资源，如下图所示：]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle创建自增长字段函数]]></title>
    <url>%2FincreaseIdOracle.html</url>
    <content type="text"><![CDATA[一.创建序列号1234567create sequence SEQ_VEN_CODEminvalue 1maxvalue 999999999999start with 74increment by 1nocachecycle; 二.创建自增长函数12345678910111213141516171819CREATE OR REPLACE FUNCTION FUN_VEN_CODE(VEN_TYPE VARCHAR2) RETURN VARCHAR2 IS VEN_CODE VARCHAR2(30);BEGIN IF VEN_TYPE = 'LOGISTICS' THEN SELECT 'L' || LTRIM(TO_CHAR(SYSDATE, 'yyyymmdd')) || LPAD(SEQ_VEN_CODE.NEXTVAL, 5, '0') INTO VEN_CODE FROM DUAL; ELSIF VEN_TYPE = 'GOODS' THEN SELECT 'G' || LTRIM(TO_CHAR(SYSDATE, 'yyyymmdd')) || LPAD(SEQ_VEN_CODE.NEXTVAL, 5, '0') INTO VEN_CODE FROM DUAL; END IF; RETURN TRIM(VEN_CODE);EXCEPTION WHEN OTHERS THEN RETURN '0';END; 三.查询 select FUN_VEN_CODE(&#39;LOGISTICS&#39;) from dual 结果：L2017101700072 select FUN_VEN_CODE(&#39;GOODS&#39;) from dual 结果：G2017101700073]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISODate转String]]></title>
    <url>%2FconvertISODateToString.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324/** * convertISODateToString * @param time 2017-09-07T16:00:00.000Z * @return */ &lt;!--more--&gt;public static String convertISODateToString(String time)&#123; if(!time.matches("\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;T\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;.\\d&#123;3&#125;Z"))&#123; return null; &#125; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); time=time.replaceFirst("T", " ").replaceFirst(".\\d&#123;3&#125;Z", ""); Date date; try &#123; date = sdf.parse(time); Calendar ca=Calendar.getInstance(); ca.setTime(date); ca.add(Calendar.HOUR_OF_DAY, 8); time = sdf.format(ca.getTime()); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return time; &#125; 参考文章]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[业务流程异常处理]]></title>
    <url>%2FserviceException.html</url>
    <content type="text"><![CDATA[一、异常分类在web系统开发中，异常可大致分为: 系统异常:软件的缺陷，客户端对此类异常是无能为力的,系统内部未知异常。 业务异常用户未按正常流程操作导致的异常。 二、处理方式在实际开发中，常见的异常处理方式有:1.系统异常采用try{}catch{}处理,在service抛出异常，由controller层得到异常信息在返回,最好定义一个异常信息枚举类，集中记录异常信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556`service`层：try &#123; //service代码 &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ServiceException(ErrorCode.SYSTEM_ERROR); &#125;枚举类`ErrorCode`：/** * @author * errorCode 错误代码 * sysMsg 系统显示信息（一般用于日志输出） * showMsg 页面显示信息（一般用于页面提示用户） * */public enum ErrorCode &#123; SYSTEM_ERROR(10086,"","系统异常！"), CODE_EXIST(101111101,"","code码已存在已存在！"); int errorCode; String sysMsg; String showMsg; ErrorCode(int errorCode, String sysMsg, String showMsg)&#123; this.errorCode = errorCode; this.sysMsg = sysMsg; this.showMsg = showMsg; &#125; public int getErrorCode()&#123; return errorCode; &#125; public String getSysMsg()&#123; return sysMsg; &#125; public String getShowMsg()&#123; return showMsg; &#125; public void setShowMsg(String showMsg)&#123; this.showMsg = showMsg; &#125; public void setSysMsg(String sysMsg)&#123; this.sysMsg = sysMsg; &#125;&#125;`controller`层：try &#123; //controller代码 &#125; catch (ModuleException e) &#123; //通过枚举类返回错误码和错误信息 return ResponseError.create(e.getErrorCode().getErrorCode(),e.getErrorCode().getShowMsg()); &#125; 2.业务异常可以采用try{}catch{}处理，或者采用if加错误码判断处理如果采用try{}catch{}方式，和上面方式一致，下面介绍采用if加错误码处理,定义一个对象，每次处理加上返回码和错误信息提示。12345ReturnResultObj obj = new ReturnResultObj();obj.setCode("101112101");obj.setMessage("name不能为空!");obj.setData("");return obj; 三、两种方式优缺点： 用if加错误码控制业务流程,需要对每个接口的返回都要做一个错误码的校验,判断的代码会遍布在你的业务代码里面。优点就是对调用方,不必对你的接口进行异常校验,因为你的接口只可能返回「正确」或者「错误」,代码可读性高，但是随之带来的代码显得很臃肿，错误码集中在代码里，后期维护困难，但在效率上面也会更加高一点。对某些人来说,用错误码来控制业务流程更能符合「异常」的语义。 用if加错误码控制业务流程,因为没有抛出RuntimeException，如果在写操作之后加入业务判断，会导致事务无法回滚，因此写操作之前进行所有业务判断。 用异常来控制业务流程,可以把错误处理集中在一处,对客户端的代码编写更加友好,代码清晰简洁，在业务代码里面不会有很多错误码的判断。缺点就是创建异常堆栈是需要时间和空间的,异常处理性能开销在于-是一个synchronized方法(主因)-需要填充线程运行堆栈信息但是可以通过复写业务异常基类的方法Throwable.fillInStackTrace()来提示性能。123public Throwable fillInStackTrace() &#123; return null;&#125; 参考文章:https://segmentfault.com/q/1010000004308144?_ea=564305http://blog.csdn.net/liujun13579/article/details/7742380]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>业务，异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis嵌套查询两种方式]]></title>
    <url>%2FMybatisNestedSelect.html</url>
    <content type="text"><![CDATA[resultMap constructor - 类在实例化时,用来注入结果到构造方法中 dArg - ID 参数;标记结果作为 ID 可以帮助提高整体效能 arg - 注入到构造方法的一个普通结果 id – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能 result – 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂的类型关联;许多结果将包成这种类型 嵌入结果映射 – 结果映射自身的关联,或者参考一个 collection – 复杂类型的集 + javaType - 集合类型 + ofType - 子对象的Java数据类型 + autoMapping - 开启自动映射 嵌套嵌入结果映射, 结果映射自身的集,或者参考一个 collection标签中的select属性，通过这个属性，通过ID引用另一个加载复杂类型的映射语句。从指定列属性中返回的值，将作为参数设置给目标select 语句。注意：在处理组合键时，也就是传入多个参数时，可以使用column=”{pro1=col1,pro2=col2}”这样的语法，这就会把prop1和prop2设置到目标嵌套语句的参数对象中，在子查询中就可以作为参数使用#{pro1},#{pro2}。 discriminator – 使用结果值来决定使用哪个结果映射 case – 基于某些值的结果映射嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。 第一种：子查询12345678910111213141516171819202122232425262728293031323334&lt;select id="getTest" parameterType="Test" resultMap="getTestMap"&gt; select AAA, BBB, CCC from test where '1' = '1' and AAA = #&#123;aaa,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" column="&#123;aaa=AAA,bbb=BBB&#125;" ofType="TestValue" javaType="ArrayList" select="selectTestValues"/&gt;&lt;/resultMap&gt;&lt;select id="selectTestValues" resultMap="selectTestValuesMap"&gt; select DDD, EEE from test_value where AAA = #&#123;aaa,jdbcType=VARCHAR&#125; and BBB = #&#123;bbb,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;resultMap id="selectTestValuesMap" type="TestValue" &gt; &lt;result column="DDD" property="ddd" jdbcType="VARCHAR" /&gt; &lt;result column="EEE" property="eee" jdbcType="VARCHAR" /&gt;&lt;/resultMap&gt; 第二种多表连接把所有结果查询出来，resultMap开启开启自动映射或着在resultMap中填写需要合并的字段，这种方式由于是先查出所有结果，然后利用resultMap对结果合并，所以分页很难做。123456&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" ofType="TestValue" javaType="ArrayList" autoMapping="true"/&gt;&lt;/resultMap&gt; 或者：123456789&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" ofType="TestValue" javaType="ArrayList"&gt; &lt;result column="DDD" property="ddd" jdbcType="VARCHAR" /&gt; &lt;result column="EEE" property="eee" jdbcType="VARCHAR" /&gt; &lt;/collection&gt; &lt;/resultMap&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Mybatis</tag>
        <tag>管理查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库批量插入、批量更新]]></title>
    <url>%2ForacleInsert.html</url>
    <content type="text"><![CDATA[一.xml中批量插入三种方式 1.使用union all sql中没有VALUES 中的select…插入数据…from dual 1234567891011122017/10/18INSERT INTO STUDENT ( NAME， AGE )&lt;foreach collection="templateDetial" item="item" index="index" separator="union all" &gt; SELECT #&#123;item.name&#125;, #&#123;item.age&#125; FROM DUAL &lt;/foreach&gt; 2.insert all sql中有VALUES 分隔符是空格,这种方式可以返回插入总条数 12345678910111213INSERT ALL &lt;foreach collection="list" item="item" index="index" separator=" "&gt; INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) &lt;/foreach&gt;SELECT 1 FROM DUAL 批量插入多表 12345678910111213141516171819202122INSERT ALL &lt;foreach collection="carouselList" item="item" index="index" separator=" "&gt; INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) INTO STUDENT2 ( NAME2， AGE2 ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) &lt;/foreach&gt;SELECT 1 FROM DUAL 3.begin end模式 分隔符是 ;插入成功，返回插入总条数始终未-11234567891011&lt;foreach collection="list" item="item" index="index" open="begin" close=";end;" separator=";"&gt; INSERT INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; )&lt;/foreach&gt; 二.在代码中使用batch模式,效率最高Mybatis有三种执行器： SIMPLE是普通的执行器，相当于JDBC的stmt.execute(sql) REUSE执行器会重用预处理语句(prepared statements)，相当于JDBC重用一条sql，再通过stmt传入多项参数值，然后执行stmt.executeUpdate()或stmt.executeBatch() BATCH执行器将重用语句并执行批量更新，相当于JDBC语句的stmt.addBatch(sql)，即仅仅是将执行SQL加入到批量计划。当插入主键时不会抛出主键冲突等运行时异常，而只有临近commit前执行stmt.execteBatch()后才会抛出异常。1234567891011121314151617181920212223242526public void test() &#123; //新获取一个模式为BATCH，自动提交为false的session //如果自动提交设置为true,将无法控制提交的条数，改为最后统一提交，可能导致内存溢出 SqlSession session = sqlSessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH, false); //通过新的session获取mapper testMapper = session.getMapper(testMapper.class); int size = 10000; try &#123; for (int i = 0; i &lt; size; i++) &#123; Test test = new Test(); test.setName(String.valueOf(System.currentTimeMillis())); testMapper.insert(test); if (i % 1000 == 0 || i == size - 1) &#123; //手动每1000个一提交，提交后无法回滚 session.commit(); //清理缓存，防止溢出 session.clearCache(); &#125; &#125; &#125; catch (Exception e) &#123; //没有提交的数据可以回滚 session.rollback(); &#125; finally &#123; session.close(); &#125;&#125; 三.批量更新12345678910&lt;update id="updateStudent" parameterType="java.util.List"&gt; &lt;foreach collection="list" item="item" index="index" open="begin" close=";end;" separator=";"&gt; UPDATE STUDENT SET AGE = '0' WHERE NAME = #&#123;item.name&#125; &lt;/foreach&gt;&lt;/update&gt; 返回结果为 -1 参考链接MyBatis的几种批量操作关于Mybatis的Batch模式性能测试及结论]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>
