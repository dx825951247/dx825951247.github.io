<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[两数相加]]></title>
    <url>%2F2.html</url>
    <content type="text"><![CDATA[LeetCode-002题目描述给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 答案:1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode rootNode = new ListNode(0); ListNode p = rootNode; int carry = 0; int sum; //进位也加入判断，不然会出现 [1] [9,9] 结果为[0,10,1]的错误情况 while (null != l1 || null != l2 || carry == 1) &#123; int num1 = (null == l1 ? 0 : l1.val); int num2 = (null == l2 ? 0 : l2.val); if (num1 + num2 + carry &gt; 9) &#123; sum = (carry + num1 + num2) % 10; carry = 1; &#125; else &#123; sum = carry + num1 + num2; carry = 0; &#125; p.next = new ListNode(sum); p = p.next; l1 = (null == l1 ? null : l1.next); l2 = (null == l2 ? null : l2.next); &#125; return rootNode.next;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F1.html</url>
    <content type="text"><![CDATA[LeetCode-001题目描述给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 答案:12345678910111213public static int[] twoSum(int[] nums, int target) &#123; int pre, aft; int len = nums.length; for (pre = 0; pre &lt; len - 1; pre++) &#123; for (aft = pre + 1; aft &lt; len; aft++) &#123; int sum = nums[pre] + nums[aft]; if (sum == target) &#123; return new int[] &#123; pre, aft &#125;; &#125; &#125; &#125; return null;&#125; 此方法效率不高，可以利用哈希表优化,如下所示：12345678910111213public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); int[] res = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; if (m.containsKey(target - nums[i])) &#123; res[0] = m.get(target - nums[i]); res[1] = i; break; &#125; m.put(nums[i], i); &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰表达式]]></title>
    <url>%2FalgorithmsRPN.html</url>
    <content type="text"><![CDATA[一个字符串表达式如：1+2*3-4+2*(5-2*(2-1)),求出表达式值，答案为9。这种类型的题目可用逆波兰表达式解决，逆波兰表达式又称作后缀表达式，在四则混合运算中经常用到。4+5*(3-2)逆波兰式是4532-*+1+2*3/3/4*2-4+2*(5-2*(2-1))逆波兰式是123*3/4/2*4-25221-*-*++1+2*3-4+2*(5-2*(2-1))逆波兰式是123*4-25221-*-*++算法如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class ReversePolishNotation &#123; public static void main(String[] args) &#123; String expression = "1+2*3/3/4*2-4+2*(5-2*(2-1))"; // String expression = "1+2*3-4+2*(5-2*(2-1))"; List&lt;Character&gt; a = createRPN(expression); System.out.println(a); int b = calc(a); System.out.println(b); &#125; // 生成逆波兰表达式 public static List&lt;Character&gt; createRPN(String expression) &#123; if (null == expression || "".equals(expression)) &#123; return null; &#125; Stack&lt;Character&gt; operandStack = new Stack&lt;Character&gt;(); Stack&lt;Character&gt; operatorStack = new Stack&lt;Character&gt;(); char[] elements = expression.toCharArray(); for (int i = 0; i &lt; elements.length; i++) &#123; char element = elements[i]; if (Character.isDigit(element)) &#123; operandStack.push(element); &#125; else if (element == '(') &#123; operatorStack.push(element); &#125; else if (element == ')') &#123; char s; while ((s = operatorStack.pop()) != '(') &#123; operandStack.push(s); &#125; &#125; else &#123; if (operatorStack.empty()) &#123; operatorStack.push(element); &#125; else if (priorty(element, operatorStack.peek())) &#123; operatorStack.push(element); &#125; else &#123; operandStack.push(operatorStack.pop()); operatorStack.push(element); &#125; &#125; &#125; while (!operatorStack.empty()) &#123; operandStack.push(operatorStack.pop()); &#125; List&lt;Character&gt; s = new ArrayList&lt;Character&gt;(); while (!operandStack.empty()) &#123; s.add(operandStack.pop()); &#125; return s; &#125; // 比较字符优先级 //当新添加的操作费是 * /，或者栈顶是(时，操作符优先级高 public static boolean priorty(char s1, char s2) &#123; if ((s1 == '*' || s1 == '/') &amp;&amp; (s2 == '+' || s2 == '-')) &#123; return true; &#125; if ((s2 == '(' || s2 == ')')) &#123; return true; &#125; else &#123; return false; &#125; &#125; // 波兰表达式计算 public static int calc(List&lt;Character&gt; expression) &#123; Stack&lt;Integer&gt; calcStack = new Stack&lt;Integer&gt;(); int sum = 0; int num1; int num2; for (int i = expression.size() - 1; i &gt;= 0; i--) &#123; char c = (char) expression.get(i); if (Character.isDigit(c)) &#123; calcStack.push(c - '0'); &#125; if (c == '+') &#123; num1 = calcStack.pop(); num2 = calcStack.pop(); calcStack.push(num2 + num1); &#125; else if (c == '-') &#123; num1 = calcStack.pop(); num2 = calcStack.pop(); calcStack.push(num2 - num1); &#125; else if (c == '*') &#123; num1 = calcStack.pop(); num2 = calcStack.pop(); calcStack.push(num2 * num1); &#125; else if (c == '/') &#123; num1 = calcStack.pop(); num2 = calcStack.pop(); calcStack.push(num2 / num1); &#125; &#125; return calcStack.pop(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis异常Unexpected end of stream解决方案]]></title>
    <url>%2FredisUnexpectedEndOfStream.html</url>
    <content type="text"><![CDATA[项目测试环境没问题，正式环境Redis读写数据有时候会抛异常：Unexpected end of stream.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101org.springframework.data.redis.RedisConnectionFailureException: Unexpected end of stream.; nested exception is redis.clients.jedis.exceptions.JedisConnectionException: Unexpected end of stream. at org.springframework.data.redis.connection.jedis.JedisExceptionConverter.convert(JedisExceptionConverter.java:47) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.connection.jedis.JedisExceptionConverter.convert(JedisExceptionConverter.java:36) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:37) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.FallbackExceptionTranslationStrategy.translate(FallbackExceptionTranslationStrategy.java:37) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.connection.jedis.JedisConnection.convertJedisAccessException(JedisConnection.java:210) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.connection.jedis.JedisConnection.get(JedisConnection.java:1122) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:46) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:52) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:191) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:153) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:86) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:43) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at cn.com.ocj.usercenter.util.TokenManager.getString(TokenManager.java:71) ~[classes/:na] at cn.com.ocj.usercenter.util.TokenManager.getRedisToken(TokenManager.java:128) ~[classes/:na] at cn.com.ocj.usercenter.service.impl.UserServiceImpl.getLoginStatus(UserServiceImpl.java:283) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317) ~[spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98) ~[spring-tx-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:266) ~[spring-tx-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95) ~[spring-tx-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207) ~[spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at com.sun.proxy.$Proxy28.getLoginStatus(Unknown Source) ~[na:na] at cn.com.ocj.usercenter.controller.UserController.getLoginStatus(UserController.java:101) ~[classes/:na] at cn.com.ocj.usercenter.controller.UserController$$FastClassBySpringCGLIB$$30df6a33.invoke(&lt;generated&gt;) [spring-core-4.1.1.RELEASE.jar:na] at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) [spring-core-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:717) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at cn.com.ocj.usercenter.aop.ControllerAdvice.invoke(ControllerAdvice.java:68) [classes/:na] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:653) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at cn.com.ocj.usercenter.controller.UserController$$EnhancerBySpringCGLIB$$eca12e1d.getLoginStatus(&lt;generated&gt;) [spring-core-4.1.1.RELEASE.jar:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91] at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:781) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:721) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:868) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:648) [servlet-api.jar:na] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) [servlet-api.jar:na] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) [tomcat-websocket.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at com.thetransactioncompany.cors.CORSFilter.doFilter(CORSFilter.java:198) [cors-filter-2.5.jar:2.5] at com.thetransactioncompany.cors.CORSFilter.doFilter(CORSFilter.java:244) [cors-filter-2.5.jar:2.5] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at cn.com.ocj.usercenter.filter.UserLoginFilter.doFilter(UserLoginFilter.java:58) [classes/:na] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) [catalina.jar:8.0.32] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) [catalina.jar:8.0.32] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) [catalina.jar:8.0.32] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) [catalina.jar:8.0.32] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) [catalina.jar:8.0.32] at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:616) [catalina.jar:8.0.32] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) [catalina.jar:8.0.32] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:522) [catalina.jar:8.0.32] at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1095) [tomcat-coyote.jar:8.0.32] at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672) [tomcat-coyote.jar:8.0.32] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1500) [tomcat-coyote.jar:8.0.32] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1456) [tomcat-coyote.jar:8.0.32] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_91] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_91] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-util.jar:8.0.32] at java.lang.Thread.run(Thread.java:745) [na:1.8.0_91]Caused by: redis.clients.jedis.exceptions.JedisConnectionException: Unexpected end of stream. at redis.clients.util.RedisInputStream.ensureFill(RedisInputStream.java:198) ~[jedis-2.7.3.jar:na] at redis.clients.util.RedisInputStream.readByte(RedisInputStream.java:40) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.Protocol.process(Protocol.java:141) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.Protocol.read(Protocol.java:205) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:297) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.Connection.getBinaryBulkReply(Connection.java:216) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.BinaryJedis.get(BinaryJedis.java:159) ~[jedis-2.7.3.jar:na] at org.springframework.data.redis.connection.jedis.JedisConnection.get(JedisConnection.java:1120) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] ... 84 common frames omitted 起初以为是redis版本问题，后来发现Redis读取数据并不是每一次都出错，猜测可能是连接池问题，然后修改项目配置文件testOnBorrow=true,问题解决。testOnBorrow：在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；testOnReturn：在return给pool时，是否提前进行validate操作； 原来是连接池中空闲的连接过一阵子就会自动断开，但是连接池还以为连接正常,这样有时候访问Redis时，用了失效的连接，就会报错，这也就解释了为什么项目中不是总是抛异常而是偶尔发生错误。受Stack Overflow文章启发: However, testOnBorrow and testOnIdle are both false. Is it the case that one of the threads in the pool has a bad connection but wasn’t closed because the connection isn’t being pinged? 链接]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种方式生成树形菜单]]></title>
    <url>%2FrecursionMenu.html</url>
    <content type="text"><![CDATA[一、Java递归算法生成树形菜单 123456789101112131415161718192021222324252627282930313233343536373839404142//合并前菜单List&lt;TMenu&gt; rootMenuList = xxxMapper.selectByxxx(params);List&lt;TMenu&gt; menuList = new ArrayList&lt;TMenu&gt;();if (null != rootMenuList &amp;&amp; rootMenuList.size() &gt; 0) &#123; // 一级菜单 for (TMenu menu : rootMenuList) &#123; //顶级菜单父级ID为0 if (menu.getParAuthId() == 0) &#123; menuList.add(menu); &#125; &#125; //递归查询顶级菜单子菜单 if (null != menuList &amp;&amp; menuList.size() &gt; 0) &#123; for (TMenu menu : menuList) &#123; menu.setList(getChildMenuList(menu.getAuthId(),rootMenuList)); &#125; &#125;&#125;/*** 查询子菜单* @param authId* @param rootMenuList* @return*/private List&lt;TMenu&gt; getChildMenuList(Integer authId, List&lt;TMenu&gt; rootMenuList) &#123; List&lt;TMenu&gt; list = new ArrayList&lt;TMenu&gt;(); for (TMenu menu : rootMenuList) &#123; if (menu.getParAuthId() == authId) &#123; list.add(menu); &#125; &#125; if (null != list &amp;&amp; list.size() &gt; 0) &#123; for (TMenu menu : list) &#123; menu.setList(getChildMenuList(menu.getAuthId(), rootMenuList)); &#125; &#125; if (null != list &amp;&amp; list.size() == 0) &#123; return null; &#125; return list;&#125; 二、MyBatis collection 集合1234567891011121314 &lt;resultMap id="NextTreeMap" type="Menu"&gt; &lt;result column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;collection column="id" property="next" javaType="java.util.ArrayList" ofType="Menu" select="getNextNodeTree"/&gt; &lt;/resultMap&gt; &lt;select id="getNextNodeTree" resultMap="NextTreeMap"&gt; SELECT id, name FROM node WHERE par_auth_id = #&#123;id&#125;&lt;/select&gt; 这种方式当数据量大的时候，会产生大量的SELECT语句，效率低下，因此不推荐数据量大的树形菜单。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx代理Tomcat服务器获取客户端真实IP]]></title>
    <url>%2FnginxIP.html</url>
    <content type="text"><![CDATA[一、背景 Java Web项目中经常需要在后端获取前端IP，通过request.getRemoteAddr()这种方法只会获取到上一级的IP，在通过了Nginx，Apache等反向代理服务器，此方法获取的就是服务器的IP，而不是客户端的真实IP地址。 这是反向代理的原因,TCP连接是在代理和网站之间，而非用户与网站之间的；HTTP协议只是第七层协议，不会把IP层访问者的源IP信息同时发送。因此服务器无法得到客户端地真实IP，但是可以通过X-Forwarded-For绕过服务器IP地址过滤。 X-Forwarded-For（简称XFF） X-Forwarded-For是一个HTTP扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由Squid这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 RFC 7239（Forwarded HTTP Extension）标准之中。XFF的格式为：X-Forwarded-For: client, proxy1, proxy2 XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP。（注意：如果未经严格处理，可以被伪造） 二、解决方案在Nginx配置中的location节点中加入123proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 其中$proxy_add_x_forwarded_for会累加代理层的IP向后传递 服务器端通过X-Forwarded-For请求头获取IP1234567891011121314151617181920212223public static String getIpAddress(HttpServletRequest request) &#123; String ipAddress = request.getHeader("X-Forwarded-For"); if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getHeader("Proxy-Client-IP"); &#125; if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getHeader("WL-Proxy-Client-IP"); &#125; if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getRemoteAddr(); &#125; // 对于通过多个代理的情况，第一个IP为客户端真实的IP地址，多个IP按照','分割 if (null != ipAddress &amp;&amp; ipAddress.length() &gt; 15) &#123; // "***.***.***.***".length() = 15 if (ipAddress.indexOf(",") &gt; 0) &#123; ipAddress = ipAddress.substring(0, ipAddress.indexOf(",")); &#125; &#125; return ipAddress.equals("0:0:0:0:0:0:0:1") ? "127.0.0.1" : ipAddress;&#125; 三、思考 通过X-Forwarded-For获取到了客户端真实IP，但其实际上是把IP放在请求头中传递给服务器端，所以这个XFF的名称是可以自定义的。比如可以定义为my-client-IP之类，然后记得在Web程序那边设定好去取这个名为my-client-IP的头标即可。 通过request.getRemoteAddr()获取的Remote Address无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源IP，无法建立TCP连接，更不会有后面的HTTP请求。但是在正常情况下，Web服务器获取Remote Address只会获取到上一级的IP。 当多层代理或使用CDN时，如果代理服务器不把用户的真实IP传递下去，那么业务服务器将永远不可能获取到用户的真实IP。 X-Forwarded-For这种方式，客户端可以任意伪造IP，并且可以传入任意格式IP，这样会产生很多问题 如果服务端通过IP做限制，前端很容易通过修改IP跳过限制。 如果直接使用这样的IP，会带来SQL注入，服务端报错，跨站攻击等漏洞。 投票系统就可能被这种方式伪造IP刷票。 X-Forwarded-For绕过服务器IP地址过滤Nginx 如何配置来获取用户真实IP]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx不转发某些http header问题]]></title>
    <url>%2FnginxHeader.html</url>
    <content type="text"><![CDATA[当项目中使用自定义的请求头时，一定要注意请求头名称不能带有下划线，用Nginx做http代理时，像token_id这样的请求头，Nginx默认不转发，因为Nginx会默认过滤带有下划线的请求头。解决办法： 配置中http部分 增加underscores_in_headers on;配置。 用减号-替代下划线符号_，避免这种变态问题。或者不使用含有下划线的请求头。 nginx 做proxy 不转发 http header问题解决]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀文章汇总]]></title>
    <url>%2Fmark.html</url>
    <content type="text"><![CDATA[权限管理及实现思路数据库性能优化详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis数据类型值为0时非空判断问题]]></title>
    <url>%2FmybatisZeroNull.html</url>
    <content type="text"><![CDATA[123&lt;if test="age != null and age != ''"&gt; #&#123;age,jdbcType=NUMERIC&#125;&lt;/if&gt; 当age为0时，此判断不成立，sql可能报错。导致错误原因是，0被视为false，0 != &#39;&#39;自然也不会成立，数字类型进行非空字符判断本身也不合理。解决此问题办法，如下去掉非空判断：123&lt;if test="age != null"&gt; #&#123;age,jdbcType=NUMERIC&#125;&lt;/if&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next博客链接与常用Markdown语法]]></title>
    <url>%2FnextPage.html</url>
    <content type="text"><![CDATA[量子广告务虚笔记小桥流水人家Jing’s BlogDoublemine岁月如歌胡闹的日子Never_yu’s Blog SEO优化博客 Bootstrap CalloutContent (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) 将博客源文件上传至好hexo分支deploy: type: gitrepo: https://github.com/dx825951247/dx825951247.github.io.gitbranch: master type: gitrepo: https://github.com/dx825951247/dx825951247.github.io.gitbranch: hexoextend_dirs: /ignore_hidden: falseignore_pattern:public: . type: baidu_url_submitter Next标签插件Code Block1alert(&apos;Hello World!&apos;); Pull Quotecontent]]></content>
      <tags>
        <tag>Next</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis返回结果集Map or 实体类]]></title>
    <url>%2FmybatisReturn.html</url>
    <content type="text"><![CDATA[观点1：一般的配置项表的结构不太会变化，服务层还有业务操作，使用实体类好些，如果返回结果是多层组合，返回结构字段可能经常变化，多表联合查询，使用Map好些。 观点2：使用Map可读性较差，当你前端用Map接收传递参数和mybatis返回用Map接收和传递参数，如果回头阅读代码，还得去看前端请求或者具体sql返回结果。如果是他人接手你的项目，得从头到尾得读一遍你的代码。如果你返回的是一个对象实体，那他就可以看到你返回的是什么，别人也就不需要再去看你代码了，提高了开发效率。 观点3：MyBatis也是ORM(Object Relational Mapping)框架的一员，使用Map从业界准则来看，不符合面向对象思想，这是一个代码规范问题。 观点4：采用实体类比Map更耗费系统资源，如下图所示：]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle创建自增长字段函数]]></title>
    <url>%2FincreaseIdOracle.html</url>
    <content type="text"><![CDATA[一.创建序列号1234567create sequence SEQ_VEN_CODEminvalue 1maxvalue 999999999999start with 74increment by 1nocachecycle; 二.创建自增长函数12345678910111213141516171819CREATE OR REPLACE FUNCTION FUN_VEN_CODE(VEN_TYPE VARCHAR2) RETURN VARCHAR2 IS VEN_CODE VARCHAR2(30);BEGIN IF VEN_TYPE = 'LOGISTICS' THEN SELECT 'L' || LTRIM(TO_CHAR(SYSDATE, 'yyyymmdd')) || LPAD(SEQ_VEN_CODE.NEXTVAL, 5, '0') INTO VEN_CODE FROM DUAL; ELSIF VEN_TYPE = 'GOODS' THEN SELECT 'G' || LTRIM(TO_CHAR(SYSDATE, 'yyyymmdd')) || LPAD(SEQ_VEN_CODE.NEXTVAL, 5, '0') INTO VEN_CODE FROM DUAL; END IF; RETURN TRIM(VEN_CODE);EXCEPTION WHEN OTHERS THEN RETURN '0';END; 三.查询 select FUN_VEN_CODE(&#39;LOGISTICS&#39;) from dual 结果：L2017101700072 select FUN_VEN_CODE(&#39;GOODS&#39;) from dual 结果：G2017101700073]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ISODate转String]]></title>
    <url>%2FconvertISODateToString.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324/** * convertISODateToString * @param time 2017-09-07T16:00:00.000Z * @return */ &lt;!--more--&gt;public static String convertISODateToString(String time)&#123; if(!time.matches("\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;T\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;.\\d&#123;3&#125;Z"))&#123; return null; &#125; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); time=time.replaceFirst("T", " ").replaceFirst(".\\d&#123;3&#125;Z", ""); Date date; try &#123; date = sdf.parse(time); Calendar ca=Calendar.getInstance(); ca.setTime(date); ca.add(Calendar.HOUR_OF_DAY, 8); time = sdf.format(ca.getTime()); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return time; &#125; 参考文章]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[业务流程异常处理]]></title>
    <url>%2FserviceException.html</url>
    <content type="text"><![CDATA[一、异常分类在web系统开发中，异常可大致分为: 系统异常:软件的缺陷，客户端对此类异常是无能为力的,系统内部未知异常。 业务异常用户未按正常流程操作导致的异常。 二、处理方式在实际开发中，常见的异常处理方式有:1.系统异常采用try{}catch{}处理,在service抛出异常，由controller层得到异常信息在返回,最好定义一个异常信息枚举类，集中记录异常信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556`service`层：try &#123; //service代码 &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ServiceException(ErrorCode.SYSTEM_ERROR); &#125;枚举类`ErrorCode`：/** * @author * errorCode 错误代码 * sysMsg 系统显示信息（一般用于日志输出） * showMsg 页面显示信息（一般用于页面提示用户） * */public enum ErrorCode &#123; SYSTEM_ERROR(10086,"","系统异常！"), CODE_EXIST(101111101,"","code码已存在已存在！"); int errorCode; String sysMsg; String showMsg; ErrorCode(int errorCode, String sysMsg, String showMsg)&#123; this.errorCode = errorCode; this.sysMsg = sysMsg; this.showMsg = showMsg; &#125; public int getErrorCode()&#123; return errorCode; &#125; public String getSysMsg()&#123; return sysMsg; &#125; public String getShowMsg()&#123; return showMsg; &#125; public void setShowMsg(String showMsg)&#123; this.showMsg = showMsg; &#125; public void setSysMsg(String sysMsg)&#123; this.sysMsg = sysMsg; &#125;&#125;`controller`层：try &#123; //controller代码 &#125; catch (ModuleException e) &#123; //通过枚举类返回错误码和错误信息 return ResponseError.create(e.getErrorCode().getErrorCode(),e.getErrorCode().getShowMsg()); &#125; 2.业务异常可以采用try{}catch{}处理，或者采用if加错误码判断处理如果采用try{}catch{}方式，和上面方式一致，下面介绍采用if加错误码处理,定义一个对象，每次处理加上返回码和错误信息提示。12345ReturnResultObj obj = new ReturnResultObj();obj.setCode("101112101");obj.setMessage("name不能为空!");obj.setData("");return obj; 三、两种方式优缺点： 用if加错误码控制业务流程,需要对每个接口的返回都要做一个错误码的校验,判断的代码会遍布在你的业务代码里面。优点就是对调用方,不必对你的接口进行异常校验,因为你的接口只可能返回「正确」或者「错误」,代码可读性高，但是随之带来的代码显得很臃肿，错误码集中在代码里，后期维护困难，但在效率上面也会更加高一点。对某些人来说,用错误码来控制业务流程更能符合「异常」的语义。 用if加错误码控制业务流程,因为没有抛出RuntimeException，如果在写操作之后加入业务判断，会导致事务无法回滚，因此写操作之前进行所有业务判断。 用异常来控制业务流程,可以把错误处理集中在一处,对客户端的代码编写更加友好,代码清晰简洁，在业务代码里面不会有很多错误码的判断。缺点就是创建异常堆栈是需要时间和空间的,异常处理性能开销在于-是一个synchronized方法(主因)-需要填充线程运行堆栈信息但是可以通过复写业务异常基类的方法Throwable.fillInStackTrace()来提示性能。123public Throwable fillInStackTrace() &#123; return null;&#125; 参考文章:https://segmentfault.com/q/1010000004308144?_ea=564305http://blog.csdn.net/liujun13579/article/details/7742380]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>业务，异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis嵌套查询两种方式]]></title>
    <url>%2FMybatisNestedSelect.html</url>
    <content type="text"><![CDATA[resultMap constructor - 类在实例化时,用来注入结果到构造方法中 dArg - ID 参数;标记结果作为 ID 可以帮助提高整体效能 arg - 注入到构造方法的一个普通结果 id – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能 result – 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂的类型关联;许多结果将包成这种类型 嵌入结果映射 – 结果映射自身的关联,或者参考一个 collection – 复杂类型的集 + javaType - 集合类型 + ofType - 子对象的Java数据类型 + autoMapping - 开启自动映射 嵌套嵌入结果映射, 结果映射自身的集,或者参考一个 collection标签中的select属性，通过这个属性，通过ID引用另一个加载复杂类型的映射语句。从指定列属性中返回的值，将作为参数设置给目标select 语句。注意：在处理组合键时，也就是传入多个参数时，可以使用column=”{pro1=col1,pro2=col2}”这样的语法，这就会把prop1和prop2设置到目标嵌套语句的参数对象中，在子查询中就可以作为参数使用#{pro1},#{pro2}。 discriminator – 使用结果值来决定使用哪个结果映射 case – 基于某些值的结果映射嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。 第一种：子查询12345678910111213141516171819202122232425262728293031323334&lt;select id="getTest" parameterType="Test" resultMap="getTestMap"&gt; select AAA, BBB, CCC from test where '1' = '1' and AAA = #&#123;aaa,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" column="&#123;aaa=AAA,bbb=BBB&#125;" ofType="TestValue" javaType="ArrayList" select="selectTestValues"/&gt;&lt;/resultMap&gt;&lt;select id="selectTestValues" resultMap="selectTestValuesMap"&gt; select DDD, EEE from test_value where AAA = #&#123;aaa,jdbcType=VARCHAR&#125; and BBB = #&#123;bbb,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;resultMap id="selectTestValuesMap" type="TestValue" &gt; &lt;result column="DDD" property="ddd" jdbcType="VARCHAR" /&gt; &lt;result column="EEE" property="eee" jdbcType="VARCHAR" /&gt;&lt;/resultMap&gt; 第二种多表连接把所有结果查询出来，resultMap开启开启自动映射或着在resultMap中填写需要合并的字段，这种方式由于是先查出所有结果，然后利用resultMap对结果合并，所以分页很难做。123456&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" ofType="TestValue" javaType="ArrayList" autoMapping="true"/&gt;&lt;/resultMap&gt; 或者：123456789&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" ofType="TestValue" javaType="ArrayList"&gt; &lt;result column="DDD" property="ddd" jdbcType="VARCHAR" /&gt; &lt;result column="EEE" property="eee" jdbcType="VARCHAR" /&gt; &lt;/collection&gt; &lt;/resultMap&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库批量插入、批量更新]]></title>
    <url>%2ForacleInsert.html</url>
    <content type="text"><![CDATA[一.xml中批量插入三种方式 1.使用union all sql中没有VALUES 中的select…插入数据…from dual 1234567891011122017/10/18INSERT INTO STUDENT ( NAME， AGE )&lt;foreach collection="templateDetial" item="item" index="index" separator="union all" &gt; SELECT #&#123;item.name&#125;, #&#123;item.age&#125; FROM DUAL &lt;/foreach&gt; 2.insert all sql中有VALUES 分隔符是空格,这种方式可以返回插入总条数 12345678910111213INSERT ALL &lt;foreach collection="list" item="item" index="index" separator=" "&gt; INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) &lt;/foreach&gt;SELECT 1 FROM DUAL 批量插入多表 12345678910111213141516171819202122INSERT ALL &lt;foreach collection="carouselList" item="item" index="index" separator=" "&gt; INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) INTO STUDENT2 ( NAME2， AGE2 ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) &lt;/foreach&gt;SELECT 1 FROM DUAL 3.begin end模式 分隔符是 ;插入成功，返回插入总条数始终未-11234567891011&lt;foreach collection="list" item="item" index="index" open="begin" close=";end;" separator=";"&gt; INSERT INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; )&lt;/foreach&gt; 二.在代码中使用batch模式,效率最高Mybatis有三种执行器： SIMPLE是普通的执行器，相当于JDBC的stmt.execute(sql) REUSE执行器会重用预处理语句(prepared statements)，相当于JDBC重用一条sql，再通过stmt传入多项参数值，然后执行stmt.executeUpdate()或stmt.executeBatch() BATCH执行器将重用语句并执行批量更新，相当于JDBC语句的stmt.addBatch(sql)，即仅仅是将执行SQL加入到批量计划。当插入主键时不会抛出主键冲突等运行时异常，而只有临近commit前执行stmt.execteBatch()后才会抛出异常。1234567891011121314151617181920212223242526public void test() &#123; //新获取一个模式为BATCH，自动提交为false的session //如果自动提交设置为true,将无法控制提交的条数，改为最后统一提交，可能导致内存溢出 SqlSession session = sqlSessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH, false); //通过新的session获取mapper testMapper = session.getMapper(testMapper.class); int size = 10000; try &#123; for (int i = 0; i &lt; size; i++) &#123; Test test = new Test(); test.setName(String.valueOf(System.currentTimeMillis())); testMapper.insert(test); if (i % 1000 == 0 || i == size - 1) &#123; //手动每1000个一提交，提交后无法回滚 session.commit(); //清理缓存，防止溢出 session.clearCache(); &#125; &#125; &#125; catch (Exception e) &#123; //没有提交的数据可以回滚 session.rollback(); &#125; finally &#123; session.close(); &#125;&#125; 三.批量更新12345678910&lt;update id="updateStudent" parameterType="java.util.List"&gt; &lt;foreach collection="list" item="item" index="index" open="begin" close=";end;" separator=";"&gt; UPDATE STUDENT SET AGE = '0' WHERE NAME = #&#123;item.name&#125; &lt;/foreach&gt;&lt;/update&gt; 返回结果为 -1 参考链接MyBatis的几种批量操作关于Mybatis的Batch模式性能测试及结论]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>
