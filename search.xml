<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[谈谈Mybatis动态表名]]></title>
    <url>%2FMybatisPrepared.html</url>
    <content type="text"><![CDATA[我们知道Mybatis可以通过${}实现动态表名、字段名，如下面这种形式，今天谈谈为什么要用$而不用#。123456&lt;select id="" resultType="" parameterType="" statementType="STATEMENT"&gt; select $&#123;columns&#125; from $&#123;tableName&#125; where ...&lt;/select&gt; 首先从数据库中执行过程说起，一条sql从发出到返回可以分为三个过程： 1、词法语法解析 2、sql语句优化，确定执行计划 3、执行返回结果 第一步词法语法解析，把一条sql字符串转换成数据库能识别的语言; 第二步sql语句优化，比如说 where 1 = 1 and ，在sql解释器执行时会去掉1 = 1，因为1 = 1必定是true，又比如，left join cl on cl.id = c2.id and c1.id = 10 and c2.id = 10，这里的c2 = 10就会被解释器删除。不仅这样，sql还得确认是全表扫描根据物理地址扫描，是走哪种索引，表之间是怎么连接等等，这些用来执行目标SQL的步骤组合就被称为执行计划，显然执行计划可能会有很多个，sql优化器会选择最优的一种执行。 可以看出最终得到执行计划，数据库引擎执行了很多步骤，很耗费资源，如果每条sql都这么来，这就是SQL硬解析，数据库肯定吃不消。如果仅仅是查询条件不同，如select ….from … where .. = ? ，我们这里可以复用执行计划，当有同样的SQL时只需要替换?代表的占位符参数就行，这叫做SQL软解析。 Mybatis预编译就是用占位符代替变化的参数，将SQL语句模板化，我们在控制台打印的日志类似这样，select… where … = ?,就是利用#占位符使用相同的执行计划，避免重复解析，优化。 $符是SQL的一部分，这样数据库会认为参数也是sql的一部分，每次都会解析优化，不能重复利用执行计划，如果$符号作为表名字段名，数据库就不能确定执行计划，因为数据库连表名都不知道，怎么去确定具体执行步骤？这也就解释了为什么会用statementType=&quot;STATEMENT&quot;非预编译形式，不然数据库会因为无法确定执行计划报错。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL踩过的坑]]></title>
    <url>%2FMySQL.html</url>
    <content type="text"><![CDATA[工作中遇到MySQL的一些坑 1、MySQL分页数据顺序错乱重复存储引擎为MyISAM时，按照物理存储顺序存储引擎为InnoDB时，一般会按照主键排序，但并总不如此。 Re: What is The Default Sort Order of SELECTS with no ORDER BY Clause?Do not depend on order when ORDER BY is missing.Always specify ORDER BY if you want a particular order – in some situations the engine can eliminate the ORDER BY because of how it does some other step.GROUP BY forces ORDER BY. (This is a violation of the standard. It can be avoided by using ORDER BY NULL.)SELECT * FROM tbl – this will do a “table scan”. If the table has never had any DELETEs/REPLACEs/UPDATEs, the records will happen to be in the insertion order, hence what you observed.If you had done the same statement with an InnoDB table, they would have been delivered in PRIMARY KEY order, not INSERT order. Again, this is an artifact of the underlying implementation, not something to depend on. 不能过分依赖MySQL默认排序带有distinct，order by的查询，可以写成这种形式避免：SELECT * FROM (SELECT DISTINCT ... FROM ORDER BY ) LIMIT 2、自增id批量插入不连续这个问题得从MySQL InnoDB自增锁说起，自增锁是一种专门针对AUTO_INCREMENT列插入的表级别锁，为了提高MySQL的并发能力，在插入数据的行数确定时，如：insert...和replace...，如已知的插入行数位5，则InnoDB会预分配5个自增值，当有一个新的insert语句时，会读取AUTO_INCREMENT=5，这样就可以并发地执行insert语句。但如果无法提前获取插入行数，如insert...select...,replace...select,loda data...,这个时候就使用表锁。insert语句中有时会显示的设置自增字段的值，对于这种情况innodb还是会预分配给语句总行数的自增值而不是只有实际使用系统自增的行。因而有可能会造成自增字段的值不连续。设置新自增互斥方式：通过配置选项：innodb_autoinc_lock_mode，它是专门用来在使用AUTO_INCREMENT的情况下调整锁策略的，目前有三种选择：innodb_autoinc_lock_mode = 0 (“traditional” lock mode：全部使用表锁)innodb_autoinc_lock_mode = 1 (默认)(“consecutive” lock mode：可预判行数时使用新方式，不可时使用表锁)innodb_autoinc_lock_mode = 2 (“interleaved” lock mode：全部使用新方式，不安全，不适合replication)(insert select语句对于自增列会预分配 如果不够就翻倍所以你插入4条语句就分配自增列到8 插入10条语句肯定就分配到16 插入20条语句就分配到32)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串与Manacher算法]]></title>
    <url>%2F5.html</url>
    <content type="text"><![CDATA[LeetCode-005题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例：输入: “babad”输出: “bab”注意: “aba”也是一个有效答案。 输入: “cbbd”输出: “bb” 答案:1.从中心点向外扩散，复杂度O(n^2)。分两种情况，以一个字符为中心的奇字符串和以两个字符为中心的偶字符串。 12345678910111213141516171819202122232425262728public String longestPalindrome(String s) &#123; if (s.length() == 1) &#123; return s; &#125; String result = ""; int max = 0, low, high; for (int i = 0; i &lt; s.length()-1; i++) &#123; low = i;high = i; while (low &gt;= 0 &amp;&amp; high &lt; s.length() &amp;&amp; s.charAt(low) == s.charAt(high)) &#123; if (max &lt; high - low + 1) &#123; max = high - low + 1; result = s.substring(low, high + 1); &#125; low--; high++; &#125; low = i;high = i+1; while (low &gt;= 0 &amp;&amp; high &lt; s.length() &amp;&amp; s.charAt(low) == s.charAt(high)) &#123; if (max &lt; high - low + 1) &#123; max = high - low + 1; result = s.substring(low, high + 1); &#125; low--; high++; &#125; &#125; return result;&#125; ２.Manacher算法(马拉车算法)，时间复杂度为O(n)。此算法在每个字符的两边都插入一个特殊的符号，将所有可能的奇数/偶数长度的回文子串都转换成了奇数长度。其核心思想P[i] &gt;= MIN(P[2 * id - i], mx - i)，利用已知最大回文字符串，求出以某个字符为中心的最大回文字符串的长度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; private int[] p; private String s; private char[] t; public String longestPalindrome(String str) &#123; s = str; preprocess(); p = new int[t.length]; int mid = 0, right = 0; for (int i = 1; i &lt; t.length-1; i++) &#123; int mirror = 2*mid - i; if (right &gt; i) p[i] = Math.min(right - i, p[mirror]); while (t[i + (1 + p[i])] == t[i - (1 + p[i])]) p[i]++; if (i + p[i] &gt; right) &#123; mid = i; right = i + p[i]; &#125; &#125; int length = 0; int center = 0; for (int i = 1; i &lt; p.length-1; i++) &#123; if (p[i] &gt; length) &#123; length = p[i]; center = i; &#125; &#125; return s.substring((center - 1 - length) / 2, (center - 1 + length) / 2); &#125; private void preprocess() &#123; t = new char[s.length()*2 + 3]; t[0] = '$'; t[s.length()*2 + 2] = '@'; for (int i = 0; i &lt; s.length(); i++) &#123; t[2*i + 1] = '#'; t[2*i + 2] = s.charAt(i); &#125; t[s.length()*2 + 1] = '#'; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个排序数组的中位数]]></title>
    <url>%2F4.html</url>
    <content type="text"><![CDATA[LeetCode-004题目描述给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。 示例：nums1 = [1, 3]nums2 = [2]中位数是 2.0 nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 答案: 本题难度在于要求算法的时间复杂度为 O(log (m+n))，很容易联想到分治法和二分查找，下面采用二分查找的思想。 假设数组nums1的长度小于数组nums2的长度，查找中位数，可以转换为查找TopK问题。令p+q=k，k为要查找的第k个数，如果num1的第p个数小于num2的第q个数，则排除num1的前p个数，在剩下的数组里找第k-p大的数即可。以下三种情况终止: k-p等于1，也就是查询剩下的数组里最小的数。 nums1的长度为0，直接返回nums2的第k大的数。 nums1[p] = nums2[q],第k大的数就是其中任意一个。 12345678910111213141516171819202122232425262728293031323334353637383940public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (null == nums1 || null == nums2) &#123; return -1; &#125; int len1 = nums1.length; int len2 = nums2.length; int k = (len1 + len2) / 2; if ((len1 + len2) % 2 == 0) &#123; return (findTopk(nums1, nums2, 0, 0, len1, len2, k) + findTopk(nums1, nums2, 0, 0, len1, len2, k + 1)) / 2; &#125; else &#123; return findTopk(nums1, nums2, 0, 0, len1, len2, k + 1); &#125;&#125;// 寻找第K大的值public static double findTopk(int[] nums1, int[] nums2, int start1, int start2, int len1, int len2, int k) &#123; // 保证num1为短数组 if (len1 &gt; len2) &#123; return findTopk(nums2, nums1, start2, start1, len2, len1, k); &#125; // 短数组长度为0时，直接返回长数组第k值 if (len1 == 0) &#123; return nums2[start2 + k - 1]; &#125; if (k == 1) &#123; return Math.min(nums1[start1], nums2[start2]); &#125; int p = Math.min(k / 2, len1); int q = k - p; if (nums1[start1 + p - 1] &lt; nums2[start2 + q - 1]) &#123; return findTopk(nums1, nums2, start1 + p, start2, len1 - p, len2, k - p); &#125; else if (nums1[start1 + p - 1] &gt; nums2[start2 + q - 1]) &#123; return findTopk(nums1, nums2, start1, start2 + q, len1, len2 - q, k - q); &#125; else &#123; return nums1[start1 + p - 1]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaCSV读写csv文件]]></title>
    <url>%2Fcsv.html</url>
    <content type="text"><![CDATA[添加javacsv jar包 net.sourceforge.javacsv javacsv 2.01234567891011121314151617181920212223242526272829303132333435363738public static void createCSV(String filePath, List&lt;TBusiLogBackup&gt; tBusiLogBackupList) throws Exception &#123; File file = new File(filePath); FileOutputStream fos = null; boolean existFile = true; if (!file.exists()) &#123; file.createNewFile(); fos = new FileOutputStream(file); existFile = false; &#125; else &#123; //写入文件末尾处 fos = new FileOutputStream(file, true); &#125; //使用输出流创建一个CsvWriter对象来写入数据。 CsvWriter csvWriter = new CsvWriter(fos, ',', Charset.forName("UTF-8")); if (!existFile) &#123; //文件头 String[] headers = &#123; "LOG_ID", "SRC_SYS", "SRC_MOD", "BUSI_TYPE", "OPT_TYPE", "REC_PK", "UPDATE_ID", "CONTENT" &#125;; csvWriter.writeRecord(headers); &#125; for (TBusiLogBackup item : tBusiLogBackupList) &#123; csvWriter.write(String.valueOf(item.getLogId())); csvWriter.write(item.getSrcSys()); csvWriter.write(item.getSrcMod()); csvWriter.write(item.getBusiType()); csvWriter.write(item.getOptType()); csvWriter.write(item.getRecPk()); csvWriter.write(item.getUpdateId() + ""); csvWriter.write(item.getContent()); //通过发送记录分隔符来结束当前记录。 csvWriter.endRecord(); &#125; csvWriter.close(); fos.close();&#125;]]></content>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2F3.html</url>
    <content type="text"><![CDATA[LeetCode-003题目描述给定一个字符串，找出不含有重复字符的最长子串的长度。 示例：给定&quot;abcabcbb&quot;，没有重复字符的最长子串是&quot;abc&quot;，那么长度就是3。给定&quot;bbbbb&quot;，最长的子串就是&quot;b&quot;，长度是1。给定&quot;pwwkew&quot;，最长子串是&quot;wke&quot;，长度是3。请注意答案必须是一个子串，&quot;pwke&quot;是子序列而不是子串。 答案:1234567891011121314151617181920212223public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); int max = 1; if(null == s || "".equals(s))&#123; return 0; &#125; for (int i = 0; i &lt; len; i++) &#123; if (max &gt;= len - i) &#123; return max; &#125; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); set.add(s.charAt(i)); for (int j = i + 1; j &lt; len; j++) &#123; Character c = s.charAt(j); if (set.contains(c)) &#123; break; &#125; set.add(c); max = max &lt; j - i + 1 ? j - i + 1 : max; &#125; &#125; return max; &#125; 更加高效的方法：遍历该字符串，每遍历一个字母时，利用map去找该字母最近一次出现是什么时候，这两个字母之间的一段便是无重复字符的字符串。12345678910111213public int lengthOfLongestSubstring(String s) &#123; int len = s.length(),n = 0; Map&lt;Character,Integer&gt; map= new HashMap&lt;&gt;(); for(int i = 0,j = 0; i&lt;len; i++)&#123; if(map.containsKey(s.charAt(i)))&#123; j = Math.max(map.get(s.charAt(i)),j); &#125; n = Math.max(n,i-j+1); map.put(s.charAt(i),i+1); &#125; return n; &#125; 上面方法可以再次优化，因为char个数有限，可以用数组代替map 123456789101112131415public int lengthOfLongestSubstring(String s) &#123; int[] list = new int[256]; int previous = -1, right = 0, max_len = 0; for(int i=0;i&lt;list.length;i++)&#123; list[i]=-1; &#125; while(right&lt;s.length())&#123; char c = s.charAt(right); if(list[(int)c] &gt; previous) previous = list[(int)c]; max_len = Math.max(max_len, right - previous); list[(int)c] = right++; &#125; return max_len; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数相加]]></title>
    <url>%2F2.html</url>
    <content type="text"><![CDATA[LeetCode-002题目描述给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 答案:1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode rootNode = new ListNode(0); ListNode p = rootNode; int carry = 0; int sum; //进位也加入判断，不然会出现 [1] [9,9] 结果为[0,10,1]的错误情况 while (null != l1 || null != l2 || carry == 1) &#123; int num1 = (null == l1 ? 0 : l1.val); int num2 = (null == l2 ? 0 : l2.val); if (num1 + num2 + carry &gt; 9) &#123; sum = (carry + num1 + num2) % 10; carry = 1; &#125; else &#123; sum = carry + num1 + num2; carry = 0; &#125; p.next = new ListNode(sum); p = p.next; l1 = (null == l1 ? null : l1.next); l2 = (null == l2 ? null : l2.next); &#125; return rootNode.next;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F1.html</url>
    <content type="text"><![CDATA[LeetCode-001题目描述给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 答案:12345678910111213public static int[] twoSum(int[] nums, int target) &#123; int pre, aft; int len = nums.length; for (pre = 0; pre &lt; len - 1; pre++) &#123; for (aft = pre + 1; aft &lt; len; aft++) &#123; int sum = nums[pre] + nums[aft]; if (sum == target) &#123; return new int[] &#123; pre, aft &#125;; &#125; &#125; &#125; return null;&#125; 此方法效率不高，可以利用哈希表优化,如下所示：12345678910111213public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); int[] res = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; if (m.containsKey(target - nums[i])) &#123; res[0] = m.get(target - nums[i]); res[1] = i; break; &#125; m.put(nums[i], i); &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰表达式]]></title>
    <url>%2FalgorithmsRPN.html</url>
    <content type="text"><![CDATA[一个字符串表达式如：1+2*3-4+2*(5-2*(2-1)),求出表达式值，答案为9。这种类型的题目可用逆波兰表达式解决，逆波兰表达式又称作后缀表达式，在四则混合运算中经常用到。4+5*(3-2)逆波兰式是4532-*+1+2*3/3/4*2-4+2*(5-2*(2-1))逆波兰式是123*3/4/2*4-25221-*-*++1+2*3-4+2*(5-2*(2-1))逆波兰式是123*4-25221-*-*++算法如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class ReversePolishNotation &#123; public static void main(String[] args) &#123; String expression = "1+2*3/3/4*2-4+2*(5-2*(2-1))"; // String expression = "1+2*3-4+2*(5-2*(2-1))"; List&lt;Character&gt; a = createRPN(expression); System.out.println(a); int b = calc(a); System.out.println(b); &#125; // 生成逆波兰表达式 public static List&lt;Character&gt; createRPN(String expression) &#123; if (null == expression || "".equals(expression)) &#123; return null; &#125; Stack&lt;Character&gt; operandStack = new Stack&lt;Character&gt;(); Stack&lt;Character&gt; operatorStack = new Stack&lt;Character&gt;(); char[] elements = expression.toCharArray(); for (int i = 0; i &lt; elements.length; i++) &#123; char element = elements[i]; if (Character.isDigit(element)) &#123; operandStack.push(element); &#125; else if (element == '(') &#123; operatorStack.push(element); &#125; else if (element == ')') &#123; char s; while ((s = operatorStack.pop()) != '(') &#123; operandStack.push(s); &#125; &#125; else &#123; if (operatorStack.empty()) &#123; operatorStack.push(element); &#125; else if (priorty(element, operatorStack.peek())) &#123; operatorStack.push(element); &#125; else &#123; operandStack.push(operatorStack.pop()); operatorStack.push(element); &#125; &#125; &#125; while (!operatorStack.empty()) &#123; operandStack.push(operatorStack.pop()); &#125; List&lt;Character&gt; s = new ArrayList&lt;Character&gt;(); while (!operandStack.empty()) &#123; s.add(operandStack.pop()); &#125; return s; &#125; // 比较字符优先级 //当新添加的操作费是 * /，或者栈顶是(时，操作符优先级高 public static boolean priorty(char s1, char s2) &#123; if ((s1 == '*' || s1 == '/') &amp;&amp; (s2 == '+' || s2 == '-')) &#123; return true; &#125; if ((s2 == '(' || s2 == ')')) &#123; return true; &#125; else &#123; return false; &#125; &#125; // 波兰表达式计算 public static int calc(List&lt;Character&gt; expression) &#123; Stack&lt;Integer&gt; calcStack = new Stack&lt;Integer&gt;(); int sum = 0; int num1; int num2; for (int i = expression.size() - 1; i &gt;= 0; i--) &#123; char c = (char) expression.get(i); if (Character.isDigit(c)) &#123; calcStack.push(c - '0'); &#125; if (c == '+') &#123; num1 = calcStack.pop(); num2 = calcStack.pop(); calcStack.push(num2 + num1); &#125; else if (c == '-') &#123; num1 = calcStack.pop(); num2 = calcStack.pop(); calcStack.push(num2 - num1); &#125; else if (c == '*') &#123; num1 = calcStack.pop(); num2 = calcStack.pop(); calcStack.push(num2 * num1); &#125; else if (c == '/') &#123; num1 = calcStack.pop(); num2 = calcStack.pop(); calcStack.push(num2 / num1); &#125; &#125; return calcStack.pop(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis异常Unexpected end of stream解决方案]]></title>
    <url>%2FredisUnexpectedEndOfStream.html</url>
    <content type="text"><![CDATA[项目测试环境没问题，正式环境Redis读写数据有时候会抛异常：Unexpected end of stream.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101org.springframework.data.redis.RedisConnectionFailureException: Unexpected end of stream.; nested exception is redis.clients.jedis.exceptions.JedisConnectionException: Unexpected end of stream. at org.springframework.data.redis.connection.jedis.JedisExceptionConverter.convert(JedisExceptionConverter.java:47) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.connection.jedis.JedisExceptionConverter.convert(JedisExceptionConverter.java:36) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:37) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.FallbackExceptionTranslationStrategy.translate(FallbackExceptionTranslationStrategy.java:37) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.connection.jedis.JedisConnection.convertJedisAccessException(JedisConnection.java:210) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.connection.jedis.JedisConnection.get(JedisConnection.java:1122) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:46) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:52) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:191) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:153) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:86) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:43) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] at cn.com.ocj.usercenter.util.TokenManager.getString(TokenManager.java:71) ~[classes/:na] at cn.com.ocj.usercenter.util.TokenManager.getRedisToken(TokenManager.java:128) ~[classes/:na] at cn.com.ocj.usercenter.service.impl.UserServiceImpl.getLoginStatus(UserServiceImpl.java:283) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317) ~[spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98) ~[spring-tx-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:266) ~[spring-tx-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95) ~[spring-tx-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207) ~[spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at com.sun.proxy.$Proxy28.getLoginStatus(Unknown Source) ~[na:na] at cn.com.ocj.usercenter.controller.UserController.getLoginStatus(UserController.java:101) ~[classes/:na] at cn.com.ocj.usercenter.controller.UserController$$FastClassBySpringCGLIB$$30df6a33.invoke(&lt;generated&gt;) [spring-core-4.1.1.RELEASE.jar:na] at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) [spring-core-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:717) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at cn.com.ocj.usercenter.aop.ControllerAdvice.invoke(ControllerAdvice.java:68) [classes/:na] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:653) [spring-aop-4.1.1.RELEASE.jar:4.1.1.RELEASE] at cn.com.ocj.usercenter.controller.UserController$$EnhancerBySpringCGLIB$$eca12e1d.getLoginStatus(&lt;generated&gt;) [spring-core-4.1.1.RELEASE.jar:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91] at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:781) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:721) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:868) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:648) [servlet-api.jar:na] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) [servlet-api.jar:na] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) [tomcat-websocket.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at com.thetransactioncompany.cors.CORSFilter.doFilter(CORSFilter.java:198) [cors-filter-2.5.jar:2.5] at com.thetransactioncompany.cors.CORSFilter.doFilter(CORSFilter.java:244) [cors-filter-2.5.jar:2.5] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at cn.com.ocj.usercenter.filter.UserLoginFilter.doFilter(UserLoginFilter.java:58) [classes/:na] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) [catalina.jar:8.0.32] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) [catalina.jar:8.0.32] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) [catalina.jar:8.0.32] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) [catalina.jar:8.0.32] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) [catalina.jar:8.0.32] at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:616) [catalina.jar:8.0.32] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) [catalina.jar:8.0.32] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:522) [catalina.jar:8.0.32] at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1095) [tomcat-coyote.jar:8.0.32] at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672) [tomcat-coyote.jar:8.0.32] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1500) [tomcat-coyote.jar:8.0.32] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1456) [tomcat-coyote.jar:8.0.32] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_91] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_91] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-util.jar:8.0.32] at java.lang.Thread.run(Thread.java:745) [na:1.8.0_91]Caused by: redis.clients.jedis.exceptions.JedisConnectionException: Unexpected end of stream. at redis.clients.util.RedisInputStream.ensureFill(RedisInputStream.java:198) ~[jedis-2.7.3.jar:na] at redis.clients.util.RedisInputStream.readByte(RedisInputStream.java:40) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.Protocol.process(Protocol.java:141) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.Protocol.read(Protocol.java:205) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:297) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.Connection.getBinaryBulkReply(Connection.java:216) ~[jedis-2.7.3.jar:na] at redis.clients.jedis.BinaryJedis.get(BinaryJedis.java:159) ~[jedis-2.7.3.jar:na] at org.springframework.data.redis.connection.jedis.JedisConnection.get(JedisConnection.java:1120) ~[spring-data-redis-1.6.1.RELEASE.jar:1.6.1.RELEASE] ... 84 common frames omitted 起初以为是redis版本问题，后来发现Redis读取数据并不是每一次都出错，猜测可能是连接池问题，然后修改项目配置文件testOnBorrow=true,问题解决。testOnBorrow：在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；testOnReturn：在return给pool时，是否提前进行validate操作； 原来是连接池中空闲的连接过一阵子就会自动断开，但是连接池还以为连接正常,这样有时候访问Redis时，用了失效的连接，就会报错，这也就解释了为什么项目中不是总是抛异常而是偶尔发生错误。受Stack Overflow文章启发: However, testOnBorrow and testOnIdle are both false. Is it the case that one of the threads in the pool has a bad connection but wasn’t closed because the connection isn’t being pinged? 链接]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种方式生成树形菜单]]></title>
    <url>%2FrecursionMenu.html</url>
    <content type="text"><![CDATA[一、Java递归算法生成树形菜单 123456789101112131415161718192021222324252627282930313233343536373839404142//合并前菜单List&lt;TMenu&gt; rootMenuList = xxxMapper.selectByxxx(params);List&lt;TMenu&gt; menuList = new ArrayList&lt;TMenu&gt;();if (null != rootMenuList &amp;&amp; rootMenuList.size() &gt; 0) &#123; // 一级菜单 for (TMenu menu : rootMenuList) &#123; //顶级菜单父级ID为0 if (menu.getParAuthId() == 0) &#123; menuList.add(menu); &#125; &#125; //递归查询顶级菜单子菜单 if (null != menuList &amp;&amp; menuList.size() &gt; 0) &#123; for (TMenu menu : menuList) &#123; menu.setList(getChildMenuList(menu.getAuthId(),rootMenuList)); &#125; &#125;&#125;/*** 查询子菜单* @param authId* @param rootMenuList* @return*/private List&lt;TMenu&gt; getChildMenuList(Integer authId, List&lt;TMenu&gt; rootMenuList) &#123; List&lt;TMenu&gt; list = new ArrayList&lt;TMenu&gt;(); for (TMenu menu : rootMenuList) &#123; if (menu.getParAuthId() == authId) &#123; list.add(menu); &#125; &#125; if (null != list &amp;&amp; list.size() &gt; 0) &#123; for (TMenu menu : list) &#123; menu.setList(getChildMenuList(menu.getAuthId(), rootMenuList)); &#125; &#125; if (null != list &amp;&amp; list.size() == 0) &#123; return null; &#125; return list;&#125; 二、MyBatis collection 集合1234567891011121314 &lt;resultMap id="NextTreeMap" type="Menu"&gt; &lt;result column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;collection column="id" property="next" javaType="java.util.ArrayList" ofType="Menu" select="getNextNodeTree"/&gt; &lt;/resultMap&gt; &lt;select id="getNextNodeTree" resultMap="NextTreeMap"&gt; SELECT id, name FROM node WHERE par_auth_id = #&#123;id&#125;&lt;/select&gt; 这种方式当数据量大的时候，会产生大量的SELECT语句，效率低下，因此不推荐数据量大的树形菜单。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx代理Tomcat服务器获取客户端真实IP]]></title>
    <url>%2FnginxIP.html</url>
    <content type="text"><![CDATA[一、背景 Java Web项目中经常需要在后端获取前端IP，通过request.getRemoteAddr()这种方法只会获取到上一级的IP，在通过了Nginx，Apache等反向代理服务器，此方法获取的就是服务器的IP，而不是客户端的真实IP地址。 这是反向代理的原因,TCP连接是在代理和网站之间，而非用户与网站之间的；HTTP协议只是第七层协议，不会把IP层访问者的源IP信息同时发送。因此服务器无法得到客户端地真实IP，但是可以通过X-Forwarded-For绕过服务器IP地址过滤。 X-Forwarded-For（简称XFF） X-Forwarded-For是一个HTTP扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由Squid这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 RFC 7239（Forwarded HTTP Extension）标准之中。XFF的格式为：X-Forwarded-For: client, proxy1, proxy2 XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP。（注意：如果未经严格处理，可以被伪造） 二、解决方案在Nginx配置中的location节点中加入123proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 其中$proxy_add_x_forwarded_for会累加代理层的IP向后传递 服务器端通过X-Forwarded-For请求头获取IP1234567891011121314151617181920212223public static String getIpAddress(HttpServletRequest request) &#123; String ipAddress = request.getHeader("X-Forwarded-For"); if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getHeader("Proxy-Client-IP"); &#125; if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getHeader("WL-Proxy-Client-IP"); &#125; if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) &#123; ipAddress = request.getRemoteAddr(); &#125; // 对于通过多个代理的情况，第一个IP为客户端真实的IP地址，多个IP按照','分割 if (null != ipAddress &amp;&amp; ipAddress.length() &gt; 15) &#123; // "***.***.***.***".length() = 15 if (ipAddress.indexOf(",") &gt; 0) &#123; ipAddress = ipAddress.substring(0, ipAddress.indexOf(",")); &#125; &#125; return ipAddress.equals("0:0:0:0:0:0:0:1") ? "127.0.0.1" : ipAddress;&#125; 三、思考 通过X-Forwarded-For获取到了客户端真实IP，但其实际上是把IP放在请求头中传递给服务器端，所以这个XFF的名称是可以自定义的。比如可以定义为my-client-IP之类，然后记得在Web程序那边设定好去取这个名为my-client-IP的头标即可。 通过request.getRemoteAddr()获取的Remote Address无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源IP，无法建立TCP连接，更不会有后面的HTTP请求。但是在正常情况下，Web服务器获取Remote Address只会获取到上一级的IP。 当多层代理或使用CDN时，如果代理服务器不把用户的真实IP传递下去，那么业务服务器将永远不可能获取到用户的真实IP。 X-Forwarded-For这种方式，客户端可以任意伪造IP，并且可以传入任意格式IP，这样会产生很多问题 如果服务端通过IP做限制，前端很容易通过修改IP跳过限制。 如果直接使用这样的IP，会带来SQL注入，服务端报错，跨站攻击等漏洞。 投票系统就可能被这种方式伪造IP刷票。 X-Forwarded-For绕过服务器IP地址过滤Nginx 如何配置来获取用户真实IP]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx不转发某些http header问题]]></title>
    <url>%2FnginxHeader.html</url>
    <content type="text"><![CDATA[当项目中使用自定义的请求头时，一定要注意请求头名称不能带有下划线，用Nginx做http代理时，像token_id这样的请求头，Nginx默认不转发，因为Nginx会默认过滤带有下划线的请求头。解决办法： 配置中http部分 增加underscores_in_headers on;配置。 用减号-替代下划线符号_，避免这种变态问题。或者不使用含有下划线的请求头。 nginx 做proxy 不转发 http header问题解决]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀文章汇总]]></title>
    <url>%2Fmark.html</url>
    <content type="text"><![CDATA[权限管理及实现思路数据库性能优化详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis数据类型值为0时非空判断问题]]></title>
    <url>%2FmybatisZeroNull.html</url>
    <content type="text"><![CDATA[123&lt;if test="age != null and age != ''"&gt; #&#123;age,jdbcType=NUMERIC&#125;&lt;/if&gt; 当age为0时，此判断不成立，sql可能报错。导致错误原因是，0被视为false，0 != &#39;&#39;自然也不会成立，数字类型进行非空字符判断本身也不合理。解决此问题办法，如下去掉非空判断：123&lt;if test="age != null"&gt; #&#123;age,jdbcType=NUMERIC&#125;&lt;/if&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next博客链接与常用Markdown语法]]></title>
    <url>%2FnextPage.html</url>
    <content type="text"><![CDATA[量子广告务虚笔记小桥流水人家Jing’s BlogDoublemine岁月如歌胡闹的日子Never_yu’s Blog SEO优化博客 Bootstrap CalloutContent (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) 将博客源文件上传至好hexo分支deploy: type: gitrepo: https://github.com/dx825951247/dx825951247.github.io.gitbranch: master type: gitrepo: https://github.com/dx825951247/dx825951247.github.io.gitbranch: hexoextend_dirs: /ignore_hidden: falseignore_pattern:public: . type: baidu_url_submitter Next标签插件Code Block1alert(&apos;Hello World!&apos;); Pull Quotecontent]]></content>
      <tags>
        <tag>Next</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis返回结果集Map or 实体类]]></title>
    <url>%2FmybatisReturn.html</url>
    <content type="text"><![CDATA[观点1：一般的配置项表的结构不太会变化，服务层还有业务操作，使用实体类好些，如果返回结果是多层组合，返回结构字段可能经常变化，多表联合查询，使用Map好些。 观点2：使用Map可读性较差，当你前端用Map接收传递参数和mybatis返回用Map接收和传递参数，如果回头阅读代码，还得去看前端请求或者具体sql返回结果。如果是他人接手你的项目，得从头到尾得读一遍你的代码。如果你返回的是一个对象实体，那他就可以看到你返回的是什么，别人也就不需要再去看你代码了，提高了开发效率。 观点3：MyBatis也是ORM(Object Relational Mapping)框架的一员，使用Map从业界准则来看，不符合面向对象思想，这是一个代码规范问题。 观点4：采用实体类比Map更耗费系统资源，如下图所示：]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle创建自增长字段函数]]></title>
    <url>%2FincreaseIdOracle.html</url>
    <content type="text"><![CDATA[一.创建序列号1234567create sequence SEQ_VEN_CODEminvalue 1maxvalue 999999999999start with 74increment by 1nocachecycle; 二.创建自增长函数12345678910111213141516171819CREATE OR REPLACE FUNCTION FUN_VEN_CODE(VEN_TYPE VARCHAR2) RETURN VARCHAR2 IS VEN_CODE VARCHAR2(30);BEGIN IF VEN_TYPE = 'LOGISTICS' THEN SELECT 'L' || LTRIM(TO_CHAR(SYSDATE, 'yyyymmdd')) || LPAD(SEQ_VEN_CODE.NEXTVAL, 5, '0') INTO VEN_CODE FROM DUAL; ELSIF VEN_TYPE = 'GOODS' THEN SELECT 'G' || LTRIM(TO_CHAR(SYSDATE, 'yyyymmdd')) || LPAD(SEQ_VEN_CODE.NEXTVAL, 5, '0') INTO VEN_CODE FROM DUAL; END IF; RETURN TRIM(VEN_CODE);EXCEPTION WHEN OTHERS THEN RETURN '0';END; 三.查询 select FUN_VEN_CODE(&#39;LOGISTICS&#39;) from dual 结果：L2017101700072 select FUN_VEN_CODE(&#39;GOODS&#39;) from dual 结果：G2017101700073]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISODate转String]]></title>
    <url>%2FconvertISODateToString.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324/** * convertISODateToString * @param time 2017-09-07T16:00:00.000Z * @return */ &lt;!--more--&gt;public static String convertISODateToString(String time)&#123; if(!time.matches("\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;T\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;.\\d&#123;3&#125;Z"))&#123; return null; &#125; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); time=time.replaceFirst("T", " ").replaceFirst(".\\d&#123;3&#125;Z", ""); Date date; try &#123; date = sdf.parse(time); Calendar ca=Calendar.getInstance(); ca.setTime(date); ca.add(Calendar.HOUR_OF_DAY, 8); time = sdf.format(ca.getTime()); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return time; &#125; 参考文章]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[业务流程异常处理]]></title>
    <url>%2FserviceException.html</url>
    <content type="text"><![CDATA[一、异常分类在web系统开发中，异常可大致分为: 系统异常:软件的缺陷，客户端对此类异常是无能为力的,系统内部未知异常。 业务异常用户未按正常流程操作导致的异常。 二、处理方式在实际开发中，常见的异常处理方式有:1.系统异常采用try{}catch{}处理,在service抛出异常，由controller层得到异常信息在返回,最好定义一个异常信息枚举类，集中记录异常信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556`service`层：try &#123; //service代码 &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ServiceException(ErrorCode.SYSTEM_ERROR); &#125;枚举类`ErrorCode`：/** * @author * errorCode 错误代码 * sysMsg 系统显示信息（一般用于日志输出） * showMsg 页面显示信息（一般用于页面提示用户） * */public enum ErrorCode &#123; SYSTEM_ERROR(10086,"","系统异常！"), CODE_EXIST(101111101,"","code码已存在已存在！"); int errorCode; String sysMsg; String showMsg; ErrorCode(int errorCode, String sysMsg, String showMsg)&#123; this.errorCode = errorCode; this.sysMsg = sysMsg; this.showMsg = showMsg; &#125; public int getErrorCode()&#123; return errorCode; &#125; public String getSysMsg()&#123; return sysMsg; &#125; public String getShowMsg()&#123; return showMsg; &#125; public void setShowMsg(String showMsg)&#123; this.showMsg = showMsg; &#125; public void setSysMsg(String sysMsg)&#123; this.sysMsg = sysMsg; &#125;&#125;`controller`层：try &#123; //controller代码 &#125; catch (ModuleException e) &#123; //通过枚举类返回错误码和错误信息 return ResponseError.create(e.getErrorCode().getErrorCode(),e.getErrorCode().getShowMsg()); &#125; 2.业务异常可以采用try{}catch{}处理，或者采用if加错误码判断处理如果采用try{}catch{}方式，和上面方式一致，下面介绍采用if加错误码处理,定义一个对象，每次处理加上返回码和错误信息提示。12345ReturnResultObj obj = new ReturnResultObj();obj.setCode("101112101");obj.setMessage("name不能为空!");obj.setData("");return obj; 三、两种方式优缺点： 用if加错误码控制业务流程,需要对每个接口的返回都要做一个错误码的校验,判断的代码会遍布在你的业务代码里面。优点就是对调用方,不必对你的接口进行异常校验,因为你的接口只可能返回「正确」或者「错误」,代码可读性高，但是随之带来的代码显得很臃肿，错误码集中在代码里，后期维护困难，但在效率上面也会更加高一点。对某些人来说,用错误码来控制业务流程更能符合「异常」的语义。 用if加错误码控制业务流程,因为没有抛出RuntimeException，如果在写操作之后加入业务判断，会导致事务无法回滚，因此写操作之前进行所有业务判断。 用异常来控制业务流程,可以把错误处理集中在一处,对客户端的代码编写更加友好,代码清晰简洁，在业务代码里面不会有很多错误码的判断。缺点就是创建异常堆栈是需要时间和空间的,异常处理性能开销在于-是一个synchronized方法(主因)-需要填充线程运行堆栈信息但是可以通过复写业务异常基类的方法Throwable.fillInStackTrace()来提示性能。123public Throwable fillInStackTrace() &#123; return null;&#125; 参考文章:https://segmentfault.com/q/1010000004308144?_ea=564305http://blog.csdn.net/liujun13579/article/details/7742380]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>业务</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis嵌套查询两种方式]]></title>
    <url>%2FMybatisNestedSelect.html</url>
    <content type="text"><![CDATA[resultMap constructor - 类在实例化时,用来注入结果到构造方法中 dArg - ID 参数;标记结果作为 ID 可以帮助提高整体效能 arg - 注入到构造方法的一个普通结果 id – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能 result – 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂的类型关联;许多结果将包成这种类型 嵌入结果映射 – 结果映射自身的关联,或者参考一个 collection – 复杂类型的集 + javaType - 集合类型 + ofType - 子对象的Java数据类型 + autoMapping - 开启自动映射 嵌套嵌入结果映射, 结果映射自身的集,或者参考一个 collection标签中的select属性，通过这个属性，通过ID引用另一个加载复杂类型的映射语句。从指定列属性中返回的值，将作为参数设置给目标select 语句。注意：在处理组合键时，也就是传入多个参数时，可以使用column=”{pro1=col1,pro2=col2}”这样的语法，这就会把prop1和prop2设置到目标嵌套语句的参数对象中，在子查询中就可以作为参数使用#{pro1},#{pro2}。 discriminator – 使用结果值来决定使用哪个结果映射 case – 基于某些值的结果映射嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。 第一种：子查询12345678910111213141516171819202122232425262728293031323334&lt;select id="getTest" parameterType="Test" resultMap="getTestMap"&gt; select AAA, BBB, CCC from test where '1' = '1' and AAA = #&#123;aaa,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" column="&#123;aaa=AAA,bbb=BBB&#125;" ofType="TestValue" javaType="ArrayList" select="selectTestValues"/&gt;&lt;/resultMap&gt;&lt;select id="selectTestValues" resultMap="selectTestValuesMap"&gt; select DDD, EEE from test_value where AAA = #&#123;aaa,jdbcType=VARCHAR&#125; and BBB = #&#123;bbb,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;resultMap id="selectTestValuesMap" type="TestValue" &gt; &lt;result column="DDD" property="ddd" jdbcType="VARCHAR" /&gt; &lt;result column="EEE" property="eee" jdbcType="VARCHAR" /&gt;&lt;/resultMap&gt; 第二种多表连接把所有结果查询出来，resultMap开启开启自动映射或着在resultMap中填写需要合并的字段，这种方式由于是先查出所有结果，然后利用resultMap对结果合并，所以分页很难做。123456&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" ofType="TestValue" javaType="ArrayList" autoMapping="true"/&gt;&lt;/resultMap&gt; 或者：123456789&lt;resultMap id="getTestMap" type="Test"&gt; &lt;id column="AAA" property="aaa" jdbcType="VARCHAR" /&gt; &lt;result column="BBB" property="bbb" jdbcType="VARCHAR" /&gt; &lt;result column="CCC" property="ccc" jdbcType="VARCHAR" /&gt; &lt;collection property="valueList" ofType="TestValue" javaType="ArrayList"&gt; &lt;result column="DDD" property="ddd" jdbcType="VARCHAR" /&gt; &lt;result column="EEE" property="eee" jdbcType="VARCHAR" /&gt; &lt;/collection&gt; &lt;/resultMap&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Mybatis</tag>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库批量插入、批量更新]]></title>
    <url>%2ForacleInsert.html</url>
    <content type="text"><![CDATA[一.xml中批量插入三种方式 1.使用union all sql中没有VALUES 中的select…插入数据…from dual 1234567891011122017/10/18INSERT INTO STUDENT ( NAME， AGE )&lt;foreach collection="templateDetial" item="item" index="index" separator="union all" &gt; SELECT #&#123;item.name&#125;, #&#123;item.age&#125; FROM DUAL &lt;/foreach&gt; 2.insert all sql中有VALUES 分隔符是空格,这种方式可以返回插入总条数 12345678910111213INSERT ALL &lt;foreach collection="list" item="item" index="index" separator=" "&gt; INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) &lt;/foreach&gt;SELECT 1 FROM DUAL 批量插入多表 12345678910111213141516171819202122INSERT ALL &lt;foreach collection="carouselList" item="item" index="index" separator=" "&gt; INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) INTO STUDENT2 ( NAME2， AGE2 ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; ) &lt;/foreach&gt;SELECT 1 FROM DUAL 3.begin end模式 分隔符是 ;插入成功，返回插入总条数始终未-11234567891011&lt;foreach collection="list" item="item" index="index" open="begin" close=";end;" separator=";"&gt; INSERT INTO STUDENT ( NAME， AGE ) VALUES( #&#123;item.name&#125;, #&#123;item.age&#125; )&lt;/foreach&gt; 二.在代码中使用batch模式,效率最高Mybatis有三种执行器： SIMPLE是普通的执行器，相当于JDBC的stmt.execute(sql) REUSE执行器会重用预处理语句(prepared statements)，相当于JDBC重用一条sql，再通过stmt传入多项参数值，然后执行stmt.executeUpdate()或stmt.executeBatch() BATCH执行器将重用语句并执行批量更新，相当于JDBC语句的stmt.addBatch(sql)，即仅仅是将执行SQL加入到批量计划。当插入主键时不会抛出主键冲突等运行时异常，而只有临近commit前执行stmt.execteBatch()后才会抛出异常。1234567891011121314151617181920212223242526public void test() &#123; //新获取一个模式为BATCH，自动提交为false的session //如果自动提交设置为true,将无法控制提交的条数，改为最后统一提交，可能导致内存溢出 SqlSession session = sqlSessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH, false); //通过新的session获取mapper testMapper = session.getMapper(testMapper.class); int size = 10000; try &#123; for (int i = 0; i &lt; size; i++) &#123; Test test = new Test(); test.setName(String.valueOf(System.currentTimeMillis())); testMapper.insert(test); if (i % 1000 == 0 || i == size - 1) &#123; //手动每1000个一提交，提交后无法回滚 session.commit(); //清理缓存，防止溢出 session.clearCache(); &#125; &#125; &#125; catch (Exception e) &#123; //没有提交的数据可以回滚 session.rollback(); &#125; finally &#123; session.close(); &#125;&#125; 三.批量更新12345678910&lt;update id="updateStudent" parameterType="java.util.List"&gt; &lt;foreach collection="list" item="item" index="index" open="begin" close=";end;" separator=";"&gt; UPDATE STUDENT SET AGE = '0' WHERE NAME = #&#123;item.name&#125; &lt;/foreach&gt;&lt;/update&gt; 返回结果为 -1 参考链接MyBatis的几种批量操作关于Mybatis的Batch模式性能测试及结论]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Mybatis</tag>
        <tag>通用</tag>
      </tags>
  </entry>
</search>
